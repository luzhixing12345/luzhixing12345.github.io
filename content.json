{"meta":{"title":"kamilu的博客","subtitle":"个人博客,用于记录和分享计算机知识","description":"个人博客,用于记录和分享计算机知识","author":"luzhixing12345","url":"https://luzhixing12345.github.io","root":"/"},"pages":[{"title":"404","date":"2022-04-23T22:11:34.000Z","updated":"2022-04-23T22:11:45.309Z","comments":false,"path":"/404.html","permalink":"https://luzhixing12345.github.io/404.html","excerpt":"","text":""},{"title":"Slides","date":"2022-04-23T22:11:04.000Z","updated":"2022-04-23T22:11:20.524Z","comments":false,"path":"slides/index.html","permalink":"https://luzhixing12345.github.io/slides/index.html","excerpt":"","text":""},{"title":"about","date":"2022-04-27T09:47:29.000Z","updated":"2022-04-27T09:47:45.141Z","comments":false,"path":"about/index.html","permalink":"https://luzhixing12345.github.io/about/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-04-23T22:03:59.000Z","updated":"2022-04-23T22:09:14.525Z","comments":false,"path":"tags/index.html","permalink":"https://luzhixing12345.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"自制操作系统day1","slug":"OS/自制操作系统day1","date":"2022-05-14T09:00:55.000Z","updated":"2022-05-14T15:15:09.787Z","comments":true,"path":"2022/05/14/OS/自制操作系统day1/","link":"","permalink":"https://luzhixing12345.github.io/2022/05/14/OS/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Fday1/","excerpt":"","text":"day1 从计算机结构到汇编程序入门 - 2022/5/14 5/13有事鸽了一天,今天开始学习 Bz1621下载NASM+GCCVMware下载安装这个软件emm怎么说呢,容易闪退,而且书里给的汇编代码也不是特别好看,我本身是不建议手动敲一遍的,因为我自己确实敲了一遍,确实挺费劲的… 我们可以直接使用作者光盘中提供的day1/helloos0/helloos.img Vscode有很优雅的方式查看这个文件,下载插件 hexodump for VSCode 和 x86 and x86_64 Assembly 右键选择 Show Hexdump 可以观察到这个十六进制文件和书中的例子是相同的,作者的图片中似乎没有给出所有的十六进制数值有些奇怪 接着按着书上的步骤,成功使用QEMU启动 我们也可以选择直接下载QEMU,然后将目录配置到环境变量之中,重启vscode终端然后输入 qemu-system-i386 helloos.img 也可以得到类似的界面,只不过上方的文字有些不同,也许是版本的原因吧 接着作者又提供了汇编的代码,我们可以直接下载NASM,目录加入环境变量,重启vscode终端然后在命令行中输入 nasm -f bin day1.asm -o day1.img 就可以得到一个img文件了,接着使用qemu启动也是可以的 DB 0x1fe-$512(0x200)字节一个扇区,减去最后的启动程序字节0x55 0xaa两个字节剩下510(0x1fe)个字节,计算与当前位置的差自动填充0x00","categories":[],"tags":[{"name":"OS","slug":"OS","permalink":"https://luzhixing12345.github.io/tags/OS/"}]},{"title":"优雅的日志记录-logging","slug":"python/优雅的日志记录-logging","date":"2022-05-13T07:11:39.000Z","updated":"2022-05-14T02:17:38.220Z","comments":true,"path":"2022/05/13/python/优雅的日志记录-logging/","link":"","permalink":"https://luzhixing12345.github.io/2022/05/13/python/%E4%BC%98%E9%9B%85%E7%9A%84%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95-logging/","excerpt":"","text":"前言 最近在写代码的过程中遇到了一些问题,如果我想输出一些信息,如果使用print函数的话,由于深度学习项目时间较长,我会将它提交到超算进行计算,但是它并不会实时输出,我必须要等到运行结束才能看到结果,如果一点有任何异常报错退出,那么我也看不到所有的print信息. 况且使用print是一种比较简单的输出格式,输出到控制台的话无法记录下来,如果使用txt单独保存信息似乎过于原始,我希望选择一种更加优雅的方式来记录信息,于是查阅资料后尝试使用了logging模块来记录信息,体验很好,分享给大家. 参考文章: python3.7-logging模块 简书-logging模块使用教程 知乎-logging模块详解 B站视频-&lt;清晰详细&gt; 博客记录 logging模块简介 logging是python内置的模块,不需要下载就可以直接import使用 日志的等级分为五级 日志等级 描述 DEBUG 基本的调试信息,可以用于输出一些特定位置的值用于调试程序 INFO 正常的信息,可以用于输出某些节点/阶段的信息 WARNING 警告信息,可以用于输出一些不合适的错误信息,比如输入不符合预期等等 ERROR 错误信息,一些严重的错误信息 CRITICAL 严重错误信息 通常来说我们个人使用的话前三个日志等级应该就足够满足了 日志等级是从上到下,DEBUG等级的日志可以显示所有日志,CRITICAL等级就只能显示CRITICAL等级的. import logging logging.debug(&quot;debug_msg&quot;) logging.info(&quot;info_msg&quot;) logging.warning(&quot;warning_msg&quot;) logging.error(&quot;error_msg&quot;) logging.critical(&quot;critical_msg&quot;) 输出结果是 WARNING:root:warning_msg ERROR:root:error_msg CRITICAL:root:critical_msg 可以看出来默认的logging等级是WARNING 我们可以使用basicConfig函数来调整日志输出的等级 import logging logging.basicConfig(level=logging.DEBUG) logging.debug(&quot;debug_msg&quot;) logging.info(&quot;info_msg&quot;) logging.warning(&quot;warning_msg&quot;) logging.error(&quot;error_msg&quot;) logging.critical(&quot;critical_msg&quot;) 输出结果是 DEBUG:root:debug_msg INFO:root:info_msg WARNING:root:warning_msg ERROR:root:error_msg CRITICAL:root:critical_msg 这也给我们提供了一组思路,就是可以在编写程序的时候在一些位置使用DEBUG等级的日志,在某些关键节点使用INFO等级的日志作为阶段提示信息,在一些可能会需要获取用户输入的地方写入WARNING日志,在一些函数内部可以做一些判断,对错误信息打上ERROR日志,这样的话如果启用DEBUG等级的日志就可以查看到所有信息,如果没什么问题的话就使用INFO等级,只看到一些正常的阶段提示信息,这样直接就忽略了所有的DEBUG的日志,也不用去像以前一样注释print函数如果程序出错,INFO等级的日志也可以看到ERROR或CRITICAL等级的错误,进行排查 logging的进阶用法 接下来介绍logging模块的四个组件,初识这一部分的时候看文档看不太懂,后来还是看了视频的讲解对这几个组件的应用理解了很多,下面我尽可能使用平实的语言来介绍其使用方式 组件名称 用途 Logger(记录器) 创建一个基本的日志的对象 Handlers(处理器) 将记录器产生的日志信息发送到目的地 Filter(过滤器) 定向过滤显示一些日志,不显示一些日志,相比level等级有了更高的控制精度 Formatter(格式化器) 控制输出格式 这四个组件看起来不是特别好理解,一些文字描述似乎也有些云里雾里,下面我会通过一个实际的例子来介绍他们的使用方法 记录器Logger 我们先创建一个logger记录器,命名为PYTHON-LOGGER,然后将他的日志等级设置为DEBUG等级 import logging #创建记录器 （全局） logger = logging.getLoger(&quot;PYTHON-LOGGER&quot;) 值得一提的是,getLogger这个函数比较有趣,logging在定义了一个logger的名字之后,就会把这个记录器的相关信息保存起来,如果你在其他文件的位置(比如说另一个 xx.py 文件)中也使用了logger = logging.getLogeer(&quot;PYTHON-LOGGER&quot;)这样返回一个logger,他的信息与这个第一次定义过的完全相同,相当于是一个全局的变量 处理器Handler 接下来我们为这个记录器创建两个处理器(Handlers),一个用于把信息输出到控制台(console),一个用于把信息输出到日志文件(log file) import logging import sys #创建记录器 （全局） logger = logging.getLoger(&quot;PYTHON-LOGGER&quot;) logger.setLevel(logging.DEBUG) #用于输出到控制台，使用StreamHandler的处理器 consoleHandler = logging.StreamHandler(stream=sys.stdout) consoleHandler.setLevel(logging.DEBUG) #用于输出到文件，使用FileHandler处理器 fileHandler = logging.FileHandler(filename=&#x27;file.log&#x27;,mode = &quot;w&quot;) # w表示覆盖之前的文件内容，也可以使用 &quot;a&quot; 来从文件结尾接着写 fileHandler.setLevel(logging.INFO) #将处理器加入到记录器中 logger.addHandler(consoleHandler) logger.addHandler(fileHandler) 注意到我们给控制台的处理器设置了DEBUG等级,给文件处理器设置了INFO等级,也就是说现在的的fileHandler的日志等级更高,DEBUG的信息并不会输出到文件中同时注意到我们也需要给logger设置日志等级为DEBUG,因为默认的logger等级是WARNING,日志等级是层级递进的,记录器-&gt;处理器,只会显示更高等级的日志信息,所以我们的处理器日志等级要比logger更高才会显示,所以设置logger为DEBUG等级(最低) 接下来我们可以简单的记录一些信息来看一看现在是什么情况. ... logger.debug(&quot;this is a debug message&quot;) logger.info(&quot;this is a info message&quot;) logger.warning(&quot;this is a warning message&quot;) 可以看到控制台输出了三条信息,文件夹中创建了一个file.log文件,其中记录了两条信息 StreamHandler和FileHandler是两个比较常用的处理器类型,处理器的任务是将日志文件内容发送到某一个位置,这两个处理器分别是发送到流和发送到磁盘文件,当然除此之外还有其他的处理器函数 SocketHandler可以使用Socket将日志记录发送到网络套接字,建立TCP连接发送到某一个IP地址 WatchedFileHandler可以监视记录到的文件的类,如果文件发生更改，它将被关闭并使用文件名重新打开 TimedRotatingFileHandler可以按特定时间轮换替换日志文件,比如说你需要一个长时间运行在服务器上的python程序,每天的日志文件可能会很大,它可以设置按天/按时间/日志文件定时分离保存等等操作. SMTPHandler可以将日志记录邮件发送到电子邮件地址 HTTPHandler可以将日志记录消息发送到 Web 服务器 处理器的功能十分强大,基本标准库提供的处理器类型可以覆盖满足基本的日志需求. 当然作为个人使用的话其实用不到这么复杂的东西,我们使用控制台输出和文件记录两个日志处理器就可以满足我们debug文件的需求了,如果感兴趣的话可以了解一下 过滤器Filter 这个说实话我觉得没啥用,一看一过得了 过滤器的作用是可以精细的区分记录器. 比如说我们设置了多个记录器,我们可以使用过滤器来特定的显示记录器的内容,而不显示某些记录器的内容 import logging logger1 = logging.getLoger(&quot;a&quot;) logger2 = logging.getLoger(&quot;a.b&quot;) logger3 = logging.getLoger(&quot;a.b.c&quot;) logger4 = logging.getLoger(&quot;d.b.c&quot;) logger5 = logging.getLoger(&quot;d.b&quot;) logger6 = logging.getLoger(&quot;e.a&quot;) filter = logging.Filter(&quot;a.b&quot;) 过滤器的操作是与python的包名类似的,该包和其子包都会被过滤掉,也就是说2,3logger会被过滤掉,不会被记录 格式化器Formatter 格式化器是一个很有用的东西,它可以用于控制输出的格式 默认的输出格式是很简单的 DEBUG:root:debug_msg,它由三部分组成,DEBUG表示日志等级level,root是默认的记录器名字,我们可以用是getLogger来改变它的名字,debug_msg是输出的信息 我们可以使用格式化器来输出我们想要的格式 import logging import sys #创建记录器 （全局） def main(): logger = logging.getLoger(&quot;PYTHON-LOGGER&quot;) logger.setLevel(logging.DEBUG) #用于输出到控制台，使用StreamHandler的处理器 consoleHandler = logging.StreamHandler(stream=sys.stdout) consoleHandler.setLevel(logging.DEBUG) #用于输出到文件，使用FileHandler处理器 fileHandler = logging.FileHandler(filename=&#x27;file.log&#x27;,mode = &quot;w&quot;) # w表示覆盖之前的文件内容，也可以使用 &quot;a&quot; 来从文件结尾接着写 fileHandler.setLevel(logging.INFO) formatter = logging.Formatter( &quot;[%(asctime)s] [%(levelname)7s] [%(filename)8s] [%(funcName)8s] [%(lineno)3d]: %(message)s&quot;, datefmt=&quot;%Y %m/%d %H:%M:%S&quot;) fileHandler.setFormatter(formatter) consoleHandler.setFormatter(formatter) #将处理器加入到记录器中 logger.addHandler(consoleHandler) logger.addHandler(fileHandler) logger.debug(&quot;this is a debug message&quot;) logger.info(&quot;this is a info message&quot;) logger.warning(&quot;this is a warning message&quot;) if __name__ == &quot;__main__&quot;: main() 值得注意的是formatter是需要加在handler上面的 控制台的输出的结果是 [2022 05/14 00:48:31] [ DEBUG] [ demo.py] [ main] [ 29]: this is a debug message [2022 05/14 00:48:31] [ INFO] [ demo.py] [ main] [ 30]: this is a info message [2022 05/14 00:48:31] [WARNING] [ demo.py] [ main] [ 31]: this is a warning message 这是我比较喜欢的一种输出格式,我们可以设置时间,文件名,函数名,行号等等,还可以输出线程,进程,路径等等更多信息,不过对于我来说并不需要那么多 当你创建了一个logger并给了它一个名字之后(通常是项目名),你可以再次调用这个logger而不需要重新配置信息,比如再次使用getLogger(“PYTHON-LOGGER”)后使用logger.info记录日志,日志的保存方式依然和原先相同 logging的工程化用法 上述的方式已经可以基本完成需求了,但是我们可以有一种更加优雅的方式,使用配置文件. 新建一个logging.conf文件,将如下信息填入 conf文件暂不支持中文字符,否则读取的时候会出现gbk错误,所以注释都是英文写的 #./logging.conf # set a logger, root is must [loggers] keys=root,PROJECT # two handler, file and consolehandler [handlers] keys=fileHandler,consoleHandler # formatter, declear below [formatters] keys=simpleFormatter [logger_root] level=DEBUG handlers=consoleHandler [logger_PROJECT] level=DEBUG handlers=fileHandler,consoleHandler qualname=PROJECT_NAME # often choose propagate=0 propagate=0 [handler_consoleHandler] class=StreamHandler args=(sys.stdout,) level=DEBUG formatter=simpleFormatter # use TimeRotatineFileHandler is more professional [handler_fileHandler] class=handlers.TimedRotatingFileHandler # record after 3600s of midnight -&gt; 1:00, 0 means save all the previous files args=(&#x27;PROJECT_NAME.log&#x27;,&#x27;midnight&#x27;,3600,0) level=DEBUG formatter=simpleFormatter [formatter_simpleFormatter] format=[%(asctime)s] [%(levelname)7s] [%(filename)8s] [%(funcName)8s] [%(lineno)3d]: %(message)s datefmt=%Y %m/%d %H:%M:%S 这样一个配置文件的内容就完成了,我们省去了写代码的时间,直接可以通过读取配置文件来得到一个logger import logging import logging.config logging.config.fileConfig(&#x27;logging.conf&#x27;) logger = logging.getLogger(&#x27;PROJECT_NAME&#x27;) logger.debug(&quot;This is PROJECT logger, debug&quot;) logger.info(&quot;hello world&quot;) 运行结果 [2022 05/14 09:07:47] [ DEBUG] [ b.py] [&lt;module&gt;] [ 7]: This is PROJECT logger, debug [2022 05/14 09:07:47] [ INFO] [ b.py] [&lt;module&gt;] [ 9]: hello world 接下来以后我们只需要每次带着这个配置文件,然后每次修改PROJECT_NAME,这样就可以直接很方便的使用了 文件日志通常不选择覆盖写入,而是跟在后面写入,即’a’ 我个人的python工作流 https://github.com/luzhixing12345/python-template","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://luzhixing12345.github.io/tags/python/"}]},{"title":"自制操作系统day0","slug":"OS/自制操作系统day0","date":"2022-05-12T07:24:44.000Z","updated":"2022-05-14T14:16:43.131Z","comments":true,"path":"2022/05/12/OS/自制操作系统day0/","link":"","permalink":"https://luzhixing12345.github.io/2022/05/12/OS/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Fday0/","excerpt":"","text":"day0 买书,准备动手,准备动手 - 2022/5/12 虽然对于计算机专业的学生来说0就是第一天,但是我还是给一天缓冲时间吧. 明天正式开始做! 买书,搜索了下有好多推荐的大学课程,也有好多前辈已经做过的东西,还是很厉害的~,希望可以顺利完成任务吧. 最后还是决定买了这本经典的 “30天自制操作系统” 导出光盘文件 光盘文件下载 一些写在最前面的话 这个博客系列-OS应该会更新32次,day0做一些简要的介绍,day1-day30分别记录每一次的任务和学到的东西,最后一次day31用来整理所学知识和寻求进一步改进 我会完整的记录我的学习心得和历程,尽可能给出较为详细的过程和具体实践方法,所有的代码文件同步在仓库L-OS,所有的文字记录同步在博客. 不过再怎么说也难免挂一漏万,语焉不详.而且写博客的目的也不是复制书上的内容,而是整理总结,所以如果有读者浏览此博客建议跟着书走,如果遇到问题或者有些疑惑之处可以查看博客内容. 我是vscode用户,不可能照顾到每个人的软硬件环境.每个人的软件硬件,实现方法的选择也许不尽相同,不过最终都是为了一个共同的目标,也算是一个计算机学生的理想之一,写一个操作系统,仅供参考 目前我还是很纯的一个小白,对操作系统的概念和很多具体问题的实现方法尚且不清晰,希望可以通过一段时间的学习掌握操作系统的内容,并通过代码的方式独立编写一个自己的操作系统,选择此书也是想在模仿中学习,希望可以坚持下来,把完整的博客更完. 本系列博客的内容部分参考网络上其他前辈的参考文档,部分为笔者独立思考,参考文章会在开头给出,如有不当之处,欢迎留言讨论 加油~","categories":[],"tags":[{"name":"OS","slug":"OS","permalink":"https://luzhixing12345.github.io/tags/OS/"}]},{"title":"GAN网络详解(上) - 基本原理及数学推导","slug":"GAN/GAN网络详解","date":"2022-05-11T16:00:47.000Z","updated":"2022-05-12T07:23:54.548Z","comments":true,"path":"2022/05/12/GAN/GAN网络详解/","link":"","permalink":"https://luzhixing12345.github.io/2022/05/12/GAN/GAN%E7%BD%91%E7%BB%9C%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"生成对抗网络(GAN)的出现可以说在深度学习领域具有划时代的意义,如今GAN也被广泛应用于各种机器学习的场景之中.GAN系列也是我个人学习过程的收获和心得,分享出来希望可以学习进步,欢迎批评指正 本系列会分上中下三部分,分别介绍 GAN的基本原理及数学推导 GAN的不足之处以及后续的改进版本DCGAN,WGAN-CP,WGAN-GP 一个我的Github项目,使用WGAN-GP生成动漫头像","categories":[],"tags":[{"name":"GAN","slug":"GAN","permalink":"https://luzhixing12345.github.io/tags/GAN/"}]},{"title":"pytorch预训练模型下载地址","slug":"pytorch/pytorch预训练模型下载地址","date":"2022-05-09T18:30:31.000Z","updated":"2022-05-09T18:33:10.520Z","comments":true,"path":"2022/05/10/pytorch/pytorch预训练模型下载地址/","link":"","permalink":"https://luzhixing12345.github.io/2022/05/10/pytorch/pytorch%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80/","excerpt":"","text":"转载pytorch预训练模型的下载地址以及解决下载速度慢的方法侵删 # Resnet: model_urls = &#123; &#x27;resnet18&#x27;: &#x27;https://download.pytorch.org/models/resnet18-5c106cde.pth&#x27;, &#x27;resnet34&#x27;: &#x27;https://download.pytorch.org/models/resnet34-333f7ec4.pth&#x27;, &#x27;resnet50&#x27;: &#x27;https://download.pytorch.org/models/resnet50-19c8e357.pth&#x27;, &#x27;resnet101&#x27;: &#x27;https://download.pytorch.org/models/resnet101-5d3b4d8f.pth&#x27;, &#x27;resnet152&#x27;: &#x27;https://download.pytorch.org/models/resnet152-b121ed2d.pth&#x27;, &#125; # inception: model_urls = &#123; # Inception v3 ported from TensorFlow &#x27;inception_v3_google&#x27;: &#x27;https://download.pytorch.org/models/inception_v3_google-1a9a5a14.pth&#x27;, &#125; # Densenet: model_urls = &#123; &#x27;densenet121&#x27;: &#x27;https://download.pytorch.org/models/densenet121-a639ec97.pth&#x27;, &#x27;densenet169&#x27;: &#x27;https://download.pytorch.org/models/densenet169-b2777c0a.pth&#x27;, &#x27;densenet201&#x27;: &#x27;https://download.pytorch.org/models/densenet201-c1103571.pth&#x27;, &#x27;densenet161&#x27;: &#x27;https://download.pytorch.org/models/densenet161-8d451a50.pth&#x27;, &#125; # Alexnet: model_urls = &#123; &#x27;alexnet&#x27;: &#x27;https://download.pytorch.org/models/alexnet-owt-4df8aa71.pth&#x27;, &#125; # vggnet: model_urls = &#123; &#x27;vgg11&#x27;: &#x27;https://download.pytorch.org/models/vgg11-bbd30ac9.pth&#x27;, &#x27;vgg13&#x27;: &#x27;https://download.pytorch.org/models/vgg13-c768596a.pth&#x27;, &#x27;vgg16&#x27;: &#x27;https://download.pytorch.org/models/vgg16-397923af.pth&#x27;, &#x27;vgg19&#x27;: &#x27;https://download.pytorch.org/models/vgg19-dcbb9e9d.pth&#x27;, &#x27;vgg11_bn&#x27;: &#x27;https://download.pytorch.org/models/vgg11_bn-6002323d.pth&#x27;, &#x27;vgg13_bn&#x27;: &#x27;https://download.pytorch.org/models/vgg13_bn-abd245e5.pth&#x27;, &#x27;vgg16_bn&#x27;: &#x27;https://download.pytorch.org/models/vgg16_bn-6c64b313.pth&#x27;, &#x27;vgg19_bn&#x27;: &#x27;https://download.pytorch.org/models/vgg19_bn-c79401a0.pth&#x27;, &#125;","categories":[],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"https://luzhixing12345.github.io/tags/pytorch/"}]},{"title":"如何给开源项目提PR","slug":"git/如何给开源项目提PR","date":"2022-05-03T17:53:26.000Z","updated":"2022-05-03T18:02:33.298Z","comments":true,"path":"2022/05/04/git/如何给开源项目提PR/","link":"","permalink":"https://luzhixing12345.github.io/2022/05/04/git/%E5%A6%82%E4%BD%95%E7%BB%99%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%8F%90PR/","excerpt":"","text":"作为提的第一个正式且被通过的PR,我决定有必要记录一下 数据库系统实现实验课的代码存在问题,群里有同学问了但是一直没有得到解决,于是我改了下代码解决了这个问题 好,我们的重点是如何给开源项目提PR,过程很简单 首先fork该仓库到你的仓库 git clone到本地修改代码 git push上去 选择pull requests,创建一个 new pull request 写一写说明文档就可以了 过程比简单但是需要注意一些问题: 一般来说一个大型的开源项目有很多PR,他们也会给出一个PR的规范要求,需要阅读并遵守 通常来说需要新建一个dev分支,然后将代码提交到dev分支上,由管理员决定要不要merge(我这里偷懒了就没建) 我个人还是觉得PR提的正式一点,修改的有用一些才好,改改错别字文档描述啥的,就不用PR了…","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://luzhixing12345.github.io/tags/git/"}]},{"title":"gitignore使用","slug":"git/gitignore使用","date":"2022-04-29T07:51:17.000Z","updated":"2022-04-29T08:09:38.185Z","comments":true,"path":"2022/04/29/git/gitignore使用/","link":"","permalink":"https://luzhixing12345.github.io/2022/04/29/git/gitignore%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Github官方.gitigore规范 .gitignore文件用来剔除不希望git上传的文件,包括 编译的中间文件 不重要的文件 一些项目运行阶段生成的文件 一些大文件(超过git默认的100M) 如果使用了Commitizen作为代码规范commit,我的个人.gitignore配置如下 /node_modules/ .vscode CHANGELOG.md *.json 同时可以使用GitHub官方提供的不同语言的gitignore文件,创建仓库是可以直接选择gitignore文件 .gitignore文件通常需要根据具体的项目目录文件进行调整,需要自建.gitignore文件以定向剔除,也可以在多个文件夹下建立.gitignore 值得一提的是,gitignore中新加入的项并不会从已上传的仓库中删除,也就是说如果你已经上传了cpp文件后在gitignore中去除*.cpp,已上传的cpp并不会被删除.这是因为在暂存区拥有该文件的备份,使用git add命令如果文件未修改则直接使用备份,使gitignore生效的方法如下 稍微改动当前文件,空格/换行 清除暂存区的cached之后git add即可 git rm -r --cached . git add . ... GitHub并不支持上传空文件夹,这个其实算是git设计时的失误,原回答,可以使用gitignore或者readme占位 Can I add empty directories? --- 目前，Git索引（staging area）的设计只允许列出文件， 没有人有足够的能力进行更改以允许空目录，也没有人足够关心这种情况来纠正它。 在目录中添加文件时会自动添加目录。也就是说，目录不必添加到存储库中，也不需要单独跟踪。 你可以说“git add&lt;dir&gt;”，它会将文件添加到其中。 如果你真的需要一个目录存在于签出中，你应该在其中创建一个文件。 gitignore可以很好地实现这一目的（还有一个使用.NET framework的工具MarkEmptyDirs， 它允许您自动完成这项任务）；您可以将其留空，或填写不希望出现在目录中的文件名。 GitHub本身是不建议仓库体积很大的","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://luzhixing12345.github.io/tags/git/"}]},{"title":"markdown语法","slug":"杂/markdown语法","date":"2022-04-29T07:50:27.000Z","updated":"2022-04-29T10:21:51.934Z","comments":true,"path":"2022/04/29/杂/markdown语法/","link":"","permalink":"https://luzhixing12345.github.io/2022/04/29/%E6%9D%82/markdown%E8%AF%AD%E6%B3%95/","excerpt":"","text":"GitHub官方文档 gitee简洁版 gitee详细版 vscode markdown插件 Markdown All in One: 预览markdown文件 侧方预览 ctrl+K+V 建议改键位,我感觉很难受 打开预览 ctrl+shift+V Markdown PDF: markdown转pdf/json/html/png/jepg Markdown Preview Mermaid Support: 预览mermaid语法 Markdown Preview Github Styling: Github版markdown预览格式 Markdownlint: markdown语法检测 Git Graph: 可视化git commit/branch流程,配合git 纯markdown语法仅仅支持很少的一部分,不过现在为了美观有很多与html结合的方式,扩展了md的适用不过还是建议,markdown做好自己的就好了,别到时候一个md写的跟html一样到处是&lt;&gt;,那可就本末倒置了 表格 First Header Second Header Content Cell Content Cell Content Cell Content Cell 单元格的宽度可以变化，不需要在列内完全对齐。标题行的每列中必须至少有三个连字符 您可以在表格中使用格式设置，例如链接、内联代码块和文本样式 左 | 中 | 右对齐 Left-aligned Center-aligned Right-aligned git status git status git status git diff git diff git diff 折叠 CLICK ME 折叠部分支持所有markdown语法和html语法,注意与summary之间要空行 We can hide anything, even code puts &quot;Hello World&quot; star 创建有趣的图表 Here is a simple flow chart: graph TD; A-->B; A-->C; B-->D; C-->D; 更多使用 使用集成mermaid的markdown编辑器-&gt; typora vscode下载插件 Markdown Preview Mermaid Support mermaid官方中文文档 知乎教程 上标下标,也可使用latex数学公式 O2 H2O 下划线 更多下划线模式 HTML标签 Please press Ctrl + Shift + R to re-render an MDN page. 注音 我（wǒ） 爱（ài） 你（nǐ） 中（zhōng） 国（guó） 插入图片 &lt;div align=center&gt;&lt;img src=&quot;https://xxx.png&quot; height=&quot;300&quot; alt=&quot;抚子妹妹&quot;&gt; 控制图片大小 对齐方式 建议转化为pdf 注脚 使用 Markdown1 可以效率的书写文档，直接转换成 HTML[2], 你可以使用 Typora[^T] 软件 视频 github 官方页面并不支持latex语法和iframe标签 嵌入视频 音频 Markdown 是一种纯文本标记语言。 ↩HyperText Markup Language 超文本标记语言。 ↩","categories":[],"tags":[{"name":"杂","slug":"杂","permalink":"https://luzhixing12345.github.io/tags/%E6%9D%82/"}]},{"title":"git的branch和pull","slug":"git/git的branch和pull","date":"2022-04-29T07:47:52.000Z","updated":"2022-04-29T07:48:06.336Z","comments":true,"path":"2022/04/29/git/git的branch和pull/","link":"","permalink":"https://luzhixing12345.github.io/2022/04/29/git/git%E7%9A%84branch%E5%92%8Cpull/","excerpt":"","text":"git官方提供了十分详细的描述,有很多直观的图片描述,很容易理解 我将在这部分根据我的理解给出一些描述性的图片,git的图片很好我并没有打算超越,仅作为学习记录 git官方的分支介绍 Note: “origin” 并无特殊含义 远程仓库名字 “origin” 与分支名字 “master” 一样，在 Git 中并没有任何特别的含义一样。 同时 “master” 是当你运行 git init 时默认的起始分支名字，原因仅仅是它的广泛使用， “origin” 是当你运行 git clone 时默认的远程仓库名字。 如果你运行 git clone -o booyah，那么你默认的远程分支名字将会是 booyah/master。 pull | branch 这个过程我用一个实例来演示,希望有助于理解 首先我创建了一个新的GitHub仓库(git branch),新建了一个文件夹并将他们remote连接,创建README文件并且提交上去,其过程无二致 接着我补充了一些文件信息,创建text.txt,写入一句话,补充readme,作为第二次提交 截至目前,我已经在本地做了两次修改,并且全部提交到了GitHub上面,在GitHub中可以点击commit查看所有的提交记录 如果只有我一个人的话,我只需要每次写完代码commit,也可以多次commit保存记录选取最后一次push到GitHub,这样我的GitHub和本地仓库一定是统一的且是最新的 master分支不断前进,HEAD代表你目前所在分支也不断前进,同时你的本地仓库与远程仓库处于同一位置 但是如果是多人合作编写程序的话,这样面临的一个问题是可能是你在本地做了一些工作,但是已经有人提前把工作推送到GitHub上,这就导致远程仓库的master接受了新的push,但是你的本地依然维持原样,当你编写完毕想要push你的commit时发现有错误信息 我在GitHub中手动修改README文件并且提交 同时我也在本地修改README文件并且提交 这时产生了报错信息,即拒绝了我的提交,因为我的current branch is behind(我被落下了) bashluzhi@LZX MINGW64 /g/learner_lu/git-branch (master) $ git push origin master To github.com:learner-lu/git-branch.git ! [rejected] master -&gt; master (non-fast-forward) error: failed to push some refs to &#x27;github.com:learner-lu/git-branch.git&#x27; hint: Updates were rejected because the tip of your current branch is behind hint: its remote counterpart. Integrate the remote changes (e.g. hint: &#x27;git pull ...&#x27;) before pushing again. hint: See the &#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details. git的推荐信息是使用git pull 我们使用git pull拉取对应仓库的对应分支 bashgit pull origin master git pull命令是将远程仓库与本地仓库进行统一,这里会出现一个问题: 如果是别人新建的文件,那么直接会在我的本地仓库复制;但如果是对于一个文件我也做了修改他也做了修改,这时就会产生冲突,因为不清楚这里的修改怎么做,需要手动解决冲突 vscode插件提供了方便的比较视图,可以选择接受现在的,接受当前提交到GitHub中最新的,还是都接受.解决所有冲突之后就可以commit了 bashgit commit -am &quot;solve crash&quot; 这种先pull后push的方式可以有效避免代码不同步,严格的commit检验保证了所有人的代码再提交的那一刻一定是与远程仓库的代码同步的,最新的. 但是于此同时也带来了一个问题,那就是每次我都需要处理冲突的文件,进行手动的选择接受哪一种修改,这显然不是一个好的方式,如果我交上去的东西被别人pull下来修改了,然后他把他的push上去. 那我再pull的时候又会发现不同,这显然不利于团队开发. 我们倾向于选择一种方式分开不同的开发,比如合理的分工,模块化到不同的文件夹/文件编写代码,这样就不需要处理冲突. 因为如果你没有改动这个文件夹/文件,其他人的修改会直接覆盖/更新此文件而不需要处理冲突(Fast-forward) 显然git也想到了这一点,比起创建文件夹这种本办法,git采用了分支的这种思想 我们可以创建一个新的分支dev,并且移动到这个分支 bashgit branch dev git checkout dev 如果你在这个dev分支上做开发,比如新建了一些文件,改写了一些代码,提交了commit.这些操作都不会影响之前的master分支. 如果你现在选择移动到master分支 git checkout master,你会发现所有的dev中的修改全都不见了,仍然是创建dev时的样子,你可以继续在master中做开发. 当你master处理完毕后可以再回到dev分支,这时又回到了dev分支的状态,这种分支的切换对于处理不同任务等复杂的场景十分适合 注意: 切换分支前应commit所有修改项 对于多人开发时,可以创建多个分支以供不同contributer开发,最后再合理的时刻进行合并,或者更新主分支master fetch merge 常规情况使用pull操作即可强制更新本地仓库,还可以使用git fetch git merge来进行合并 pull与fetch的区别 简单来说就是git fetch不更新master只更新origin/master,然后使用git merge合并本地master和origin/master,产生新commit提交. bashgit fetch origin git merge origin/master git commit -am &quot;successfully merge&quot; git push origin master git pull就是直接合并了本地master和本地remote 两者的本质区别就是fetch只是将远程仓库替换本地的remote,并不会修改你当前的任何文件,你可以检查fetch的内容再决定要不要合并. 而pull则直接进行合并,需要你现在处理冲突,决定是否改变文件. 普遍推荐使用git fetch + git merge 而不是 git pull,当然对于小项目来说看起来git pull更方便一些,也没有什么大问题 rebase 变基 由dev变基到master bashgit checkout dev git rebase master 它的原理是首先找到这两个分支(dev master)最近共同祖先，然后对比当前分支(dev)相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 master, 最后以此将之前另存为临时文件的修改依序应用 rebase会确保在向远程分支推送时能保持提交历史的整洁.例如向某个其他人维护的项目贡献代码时。 在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 origin/master 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。 一些其他变基过程 也可以直接使用pull + rebase的方式,快速拉取变基合并. 如果有冲突需要处理冲突,选择接受哪一种修改(见git.md). git rebase(master|REBASE 1/1) git push: failed to push some refs to bashgit pull --rebase origin master","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://luzhixing12345.github.io/tags/git/"}]},{"title":"git连接超时","slug":"git/git连接超时","date":"2022-04-29T07:44:25.000Z","updated":"2022-04-29T08:02:25.517Z","comments":true,"path":"2022/04/29/git/git连接超时/","link":"","permalink":"https://luzhixing12345.github.io/2022/04/29/git/git%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6/","excerpt":"","text":"不使用https连接,使用SSH连接(推荐) 使用RSA非对称加密算法 参考SSH key配置 SSH key配置教程 SSH SSL HTTPS 创建SSH key ssh-keygen -t rsa -C &quot;YOUR@EMAIL&quot; 默认路径保存,两个文件保存在 c:/user/luzhi/.ssh 不设置密码,跳过 然后会在上面的文件夹中生成id_rsa(私钥)和id_rsa.pub(公钥),私钥不要泄露! 打开Github-&gt;settings-&gt;SSH and GPG keys-&gt;new SSH key title随便起,将id_rsa.pub复制到下方 确定后不久会收到Github的邮件 在git bash中输入,注意就是git@github.com不是你的邮箱,该操作是将你的邮箱与github建立连接 ssh -T git@github.com yes SSH协议采用由人工判断公钥的fingerprint是否可信的方式。当使用ssh命令连接服务器时，命令行会提示如下信息: The authenticity of host '168.30.9.213 (&lt;no hostip for proxy command&gt;) can’t be established. RSA key fingerprint is 23:42:c1:e4:3f:d2:cc:37:1d:89:cb:e7:5d:be:5d:53. Are you sure you want to continue connecting (yes/no)? 如果出现Hi “用户名”! You’ve successfully authenticated, but GitHub does not provide shell access则设置成功 之后使用ssh的地址git@github.com:xxx而不是https的地址https://github.com/xxx 可以使用 git remote 查看远程仓库,默认为空. 查看远程仓库绑定的地址 git remote -v 如果已经添加origin,可以使用如下命令删除 git remote rm origin 添加GitHub仓库地址,注意添加的是SSH的地址 git remote add origin git@github.com:learner-lu/git-learning.git 然后就可以自由的push啦 git push origin master 其他解决方法(偶尔可以解决,偶尔出问题) 关掉代理(1) git config --global --unset https.https://github.com.proxy git config --global --unset http.https://github.com.proxy 关掉代理(2) git config --global --unset http.proxy git config --global --unset https.proxy UU加速器 | steam++ 见B站视频介绍","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://luzhixing12345.github.io/tags/git/"}]},{"title":"git的commit用法","slug":"git/git的commit用法","date":"2022-04-29T07:43:43.000Z","updated":"2022-04-29T08:23:41.831Z","comments":true,"path":"2022/04/29/git/git的commit用法/","link":"","permalink":"https://luzhixing12345.github.io/2022/04/29/git/git%E7%9A%84commit%E7%94%A8%E6%B3%95/","excerpt":"","text":"实话说我认为有些没必要,或许不应该在这种小事上大费周章,或许有些吹毛求疵吧,但我还是希望养成一个好的习惯 node_modules的设计…有些臃肿,不是很喜欢 参考知乎文章 环境配置 配置 npm 安装nodejs,选择LTS(长期稳定支持的版本),下载完成后配置环境 配置 Commitizen 以格式化 commit message Commitizen安装 npm install -g commitizen 安装changelog,生成changelog的工具 npm install -g conventional-changelog conventional-changelog-cli 检验是否安装成功,出现 conventional-changelog-cli@2.2.2 npm ls -g -depth=0 至此安装过程结束,以下为每次新建项目后需要执行的操作 项目根目录下创建空的package.json,然后进入到项目目录,执行以下命令会生成对应的项目信息: npm init --yes 运行下面命令,使其支持 Angular 的 Commit message 格式 commitizen init cz-conventional-changelog --save --save-exact 进入到项目目录,执行以下命令生成 CHANGELOG.md 文件 conventional-changelog -p angular -i CHANGELOG.md -s 以后,凡是用到 git commit 命令的时候统一改为 git cz ,然后就会出现选项，生成符合格式的Commit Message 内容说明 feat: A new feature (新功能) ——————————**常用** fix: A bug fix (修复bug) ——————————**常用** docs: Documentation only changes (文档改变) ——————————**常用** style: Changes that do not affect the meaning of the code (代码格式变更) refactor: A code change that neither fixes a bug nor adds a feature (某个已有功能重构) perf: A code change that improves performance (性能优化) test: Adding missing tests or correcting existing tests (增加测试) build: Changes that affect the build system or external dependencies (改变build工具,webpack/npm) ci: Changes to our CI configuration files and scripts (更改ci configuration) chore: Other changes that don&#x27;t modify src or test files (一些不更改src或者test相关文件的提交) ——————————**常用** revert: Reverts a previous commit (撤销上一次commit) ? What is the scope of this change (e.g. component or file name): (press enter to skip) 说明此次修改的影响范围，可以根据自己的情况来进行填写 - all: 表示影响很大，如修改了整体依赖 - location: 表示影响小，修改了某个小的功能 - module: 表示会影响整个模块，如登录模块等 ? Write a short, imperative tense description of the change (max 94 chars): 简要描述修改内容 ? Provide a longer description of the change: (press enter to skip) 详细描述修改内容,可跳过 ? Are there any breaking changes? (y/N) 大改动 ? A BREAKING CHANGE commit requires a body. Please enter a longer description of the commit itself: ? Describe the breaking changes: ? Does this change affect any open issues? (y/N) 解决issue时 Add issue references (e.g. &quot;fix #123&quot;, &quot;re #123&quot;.):","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://luzhixing12345.github.io/tags/git/"}]},{"title":"git的使用","slug":"git/git的使用","date":"2022-04-29T07:38:45.000Z","updated":"2022-04-29T08:23:42.862Z","comments":true,"path":"2022/04/29/git/git的使用/","link":"","permalink":"https://luzhixing12345.github.io/2022/04/29/git/git%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"由于笔者水平有限,该文档并不是git的教学文档,仅为学习了git的用法之后的总结,希望能通过整理的方式加深印象,如果对git尚不熟悉,可以参考以下文章 Git入门级参考文章 git官方文档 知乎文章 知乎文章 github markdown git电子书 git的使用 git支持linux的部分命令,包括cat,mkdir,touch,vim,rm,cd等等,也有一些常用的命令和提交格式 git不支持完整的正则表达式语法(regex es),它只支持unix fnmatch(filename pattern matching),通常来说在命令行中使用正则语法容易出现误导，如demo.c等习惯性的写法,因此采用unix的匹配写法,具体为: *匹配任意字符,任意次数 ?匹配任意字符,一次 [seq] 匹配 seq 中出现的字符,一次 [!seq] 匹配不在 seq 中出现的字符,一次 如匹配 demo.cpp可使用如下任意一种写法,正则写法如 \\w*\\.\\w* 将不被识别 *.cpp | demo.* | demo.??? 当您使用 Git 和 GitHub 协作处理项目时，例如，如果您在 Windows 计算机上工作，并且您的合作者在 macOS 中进行了更改，则 Git 可能会产生意外的结果.您可以将 Git 配置为自动处理行尾，以便与使用不同操作系统的人员进行有效协作。 git config --global core.autocrlf true 关于 add 将文件从工作区 add 到暂存区 添加所有文件 git add . 添加所有 .c git add *.c 添加 FILEPATH 文件夹下所有的文件 git add FILEPATH/ 查看添加了哪些文件 git status 关于 rm 有时候添加错误的或未完成需要修改的文件到暂存区,需要从暂存区删除该文件 删除方式 注意,这里可以使用 fnmatch匹配文件名,但是如果某一匹配项不在暂存区而在工作区未被加入,则删除失败 例如 1.txt 在暂存区中, 2.txt 未加入暂存区,则使用 git rm --cached *.txt 会删除失败 git add 不会有这个问题,可以理解为把所有匹配项都加入暂存区,重复的再加一次 从暂存区删除该文件,物理文件不删除(推荐使用),放入垃圾桶 git rm --cached FILENAME 删除暂存区中的文件和物理文件,谨慎使用 git rm --f FILENAME 删除已提交的文件夹或文件 git rm -r --cached FOLDER git add . ... 误删文件恢复 git rm 需谨慎!!! 如果处于未提交状态 # 查看所有修改项 git reset # 将FILENAME文件恢复 git checkout FILENAME 如果已经commit,那么会有些麻烦,只能退回上个版本,然后把被删除文件再找回来 git reset HEAD^ git checkout (捡垃圾) 关于 commit 将暂存区的文件上传到仓库区 提交 -m参数是一个较为常用的参数,用于将提交信息与命令放在同一行 git commit -m &quot;COMMIT MESSAGE&quot; 通常来说用于描述的commit信息应该记录更新了什么内容等等,一般来说一行足以.如果需要很多文件信息也可以使用 bashgit commit 打开commit信息文本,书写详细内容,使用方式同vim 查看commit日志(Q退出) git log 单行查看commit日志,关键信息 git log --pretty=oneline 回退到上一个版本(--hard本地代码改变.谨慎使用) git reset --hard HEAD^ 回退到上N个版本 git reset --hard HEAD~N 通常来说使用 git reset --hard HEAD^来进行版本回退是因为有人错误的提交了commit,如提交到了不同的分支(branch)或者误修改了某些文件,但这种情况还是相对较少 这里提供两种可能会遇到的情况: 比如说你今天打算改一改代码,你可以先把所有文件git add然后git commit一次,然后开始修改,a.txt b.txt c.txt等文件,修改完之后你发现测试的结果不尽如人意,或者你觉得你的修改太愚蠢了太繁琐了想要重写,这时候就可以使用git reset --hard HEAD 来回到最后一次commit的位置,这样你在a/b/c.txt中的所有修改都会撤回(注意会改变本地文件,使用时请注意),就不需要你记住修改了什么文件再一次次ctrl+z回退了. 或者如果你改了某几个文件的代码,但是想撤回某一个文件的所有修改,可以使用 git checkout -- FILENAME来撤销修改 返回到某一个指定的版本 git reflog # 查看所有commit记录,根据commit内容搜索,找到前面对应的序号 git reset --hard 3f72bae # 同步到某一版本 关于 push 将仓库区的文件上传到GitHub 有时候会出现Failed to connect to github.com port 443 after xxx ms: Timed out的报错信息或者OpenSSL fail的报错,网上的解决方法很多,有时成功有时不成功,我搜集到的所有解决方法.目前使用SSH可以无压力的上传下载使用git Git保存的并不是文件的变化差异,而是文件不同时刻的快照. git add操作是将文件加入暂存区,Git会为每个对象计算校验和(SHA-1哈希算法),保存blob对象的快照 git commit操作会单独计算每一个目录的校验和,使用多个树对象来保存blob对象的校验和,最后再计算树对象的校验和,生成一个提交对象,包含树对象的指针和所有提交信息 每次提交都会包含一个指向上次提交对象的指针 首先与远程仓库建立连接,有两种方式 直接从URL克隆仓库,默认将 origin设置为该仓库的地址 bashgit clone URL 将本地文件夹与远程仓库连接,origin对应远程仓库的地址(需要新建GitHub仓库) bashgit remote add origin git@github.com:luzhixing12345/git-learning.git 可以使用git remote -v查看远程仓库的地址,一个本地仓库可以连接多个远程仓库 默认的分支是master,也就是说我们选择将我们目前commit的本地仓库提交到某一个远程仓库的某一个分支上,我们使用 bashgit push origin master 第一次提交的时候可以选择git push -u origin master追踪此分支,这样默认选择以后都提交到origin远程仓库的master分支,之后的提交可以省略参数 bashgit push 总结: 一套基本的git/GitHub的文件流如下 初次配置 bashgit init git add . git commit -m &quot;upload all the files&quot; git remote add origin git@github.com:luzhixing12345/git-learning.git git push -u origin master 之后的所有修改 bashgit add . git commit -m &quot;update git learning and fix docs bugs&quot; git push 以上的命令已经可以满足绝大多数个人的项目开发与维护了,但是往往还有一些其他的问题,比如多人合作编写代码,比如临时修复bug等任务 git设计了很好的分支系统和项目拉取合并的方式,这一部分也十分重要,但并不是必要掌握的 接下来会介绍branch | pull | fetch | merge.这一部分可以说是git使用时最常见的问题,涉及多人合作完成项目,分支的使用|合并 优质网站 GitHub文件代理加速下载服务 (GitHub 文件/Releases/archive/gist/raw.githubusercontent.com)","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://luzhixing12345.github.io/tags/git/"}]},{"title":"使用PYPI发布python包","slug":"杂/使用PYPI发布python包","date":"2022-04-29T03:37:58.000Z","updated":"2022-04-29T08:24:07.514Z","comments":true,"path":"2022/04/29/杂/使用PYPI发布python包/","link":"","permalink":"https://luzhixing12345.github.io/2022/04/29/%E6%9D%82/%E4%BD%BF%E7%94%A8PYPI%E5%8F%91%E5%B8%83python%E5%8C%85/","excerpt":"","text":"前言: 最近在写一个python的包,使用python实现pytorch的基本功能.目前包名暂时叫lytorch.也在这里记录一下如何编写发布测试一个自己的python包 引言 熟悉python的朋友一定安装过很多第三方库,python的强大之处不仅在于简洁优雅,还有很好的社区环境,有许多无私的开源贡献者编写了许多实用高效的第三方库,比如matplotlib,numpy之类,只要你想要python实现的功能,几乎都可以搜索找到对应的python包,只需简单的pip安装,阅读相关文档了解其基本函数使用方法就可以迅速上手了,比起其他语言来说解决问题不可谓不快. 那么如果说我也希望为python的社区做出一些贡献,我能否开发一个python包用于实现一些功能呢? 当然是可以的,而且python社区十分欢迎你参与其中,为开源做出一份贡献. PYPI 那么如何去做呢? 显然在正常使用时如果我们编写了一个python的包(下假定该包名为lytorch),那么我们只需要在其同级目录下import lytorch即可使用,但是我们希望在所有位置都可以使用,在所有地方都可以使用,所有人都可以使用,那么显然我们需要将其移动到一个其他的位置,并且可以被引用到. PYPI是一个很好的平台,全称为Python Package Index,是一个开源的python包管理的网站,我们只需要将我们编写好的代码上传到PYPI上,接着通过pip install命令安装,这样包就被下载到 Lib/site-packages下了,使用import之时可以在sys.path中搜索到这个路径,找到lytorch的包,就可以成功的使用了. 如果您尚不熟悉python的import用法,可以参考python的import详解 准备与发布 我假定读者具有一定的GitHub的使用经验和python编写经验 首先注册一个PYPI账号-PYPI 注册成功之后回到主界面,右上角就是你的用户名,你将以这个身份进行登录 中间的搜索框中你可以找到所有发布在PYPI的包名,试试搜索 matplotlib pyautogui numpy 右上角进入个人project,目前没有任何项目.但是PYPI非常贴心的提供了很完整的教学文档,说明文档.如果你更倾向于阅读官方文档也可以移步至PYPI上传包 本地创建包 Github是一个很好的平台,开源项目通常会选择在这里开源源代码,我个人也比较推荐. 在GitHub上创建一个新的仓库,建议这里勾选下方两项. .gitignore 选择python license 选择MIT (如果你没有其他想法,选择MIT协议就可以了) 我个人没有勾选 README 的习惯,我通常会在本地补充一个非常完善的README文件. 下载到本地之后创建一个src目录用于保存,里面有一个lytorch目录,同级还有一个test.py文件用于之后的测试. 目录的结构如下 那么这个setup.py是用来干嘛的呢? 它就是用来打包python文件包的,新建setup.py并复制以下内容 import setuptools with open(&quot;README.md&quot;, &quot;r&quot;) as fh: long_description = fh.read() setuptools.setup( name=&quot;lytorch&quot;, version=&quot;0.0.1&quot;, author=&quot;kamilu&quot;, author_email=&quot;luzhixing12345@163.com&quot;, description=&quot;my implementation of pytorch&quot;, long_description=long_description, long_description_content_type=&quot;text/markdown&quot;, url=&quot;https://github.com/luzhixing12345/mytorch&quot;, package_dir=&#123;&#x27;&#x27;: &#x27;src&#x27;&#125;, packages=setuptools.find_packages(where=&#x27;src&#x27;), classifiers=[ &quot;Programming Language :: Python :: 3&quot;, &quot;License :: OSI Approved :: MIT License&quot;, &quot;Operating System :: OS Independent&quot;, ], ) 这里要修改的几个地方: name: 这个是你将要发布的包的名字,这里需要一个独一无二的名字 你需要自己想一个比较好记的名字,然后在PYPI里搜索一下,如果没有人之前发布过重名的包,那么这个名字就是你的了 一些小tips:这里的包名之后时要使用 pip install xxx 下载的,不建议使用大写字符不过用了也无妨,只不过没有人会希望下载的时候还要大小写转换吧你想到的包名很可能已经被占用了,毕竟总有人比你更早,换一个包名就好了,或者试试加上 py,python-,也许也早就被占用了(笑)不建议使用一个太过冗长的名字,虽然也是自己编写着玩玩,但是还是简洁为主good luck, 期待你的python包 version: 第一版的话使用 v0.0.1就可以了 author: 改为你的PYPI用户名 author_email:你的邮箱地址 description:写一段简短的描述 long_description: 这里就是你的README文件的内容了,很多人不好好写README,不过我希望可以认真的完成它 url: GitHub仓库的地址 package_dir,packages: 这两个不需要改,我们创建的时候就是放在了src目录下 classifiers: 代表适用于python3,MIT协议,操作系统无关,也不需要改 上传 python setup.py sdist bdist_wheel setup会对你的项目进行打包,结束之后你的文件夹里应该会多出一些东西 有兴趣的话你可以点开看看其中的文件信息,不过这个我们需要的只是这个dist,它是我们需要上传的 pip install twine twine upload dist/* 然后会要求输入PYPI的用户名和密码,正确输入之后即可上传 这里可能会警告说重复了,那就是你要换个name了或者出现一些其他的报错信息,检查一下相关报错信息,用户名密码之类的,或者看看它的解决方法 接下来你就可以在PYPI上看到你的包了,所有人都可以下载使用!这很令人兴奋不是么? 下载与测试 pip install lytorch 那么我们应该怎么使用呢?这一步很多教程没有讲,我在这里卡了好久… 注意我们现在目录结构是这样的 文件夹lytorch就是我们要import的 这里的lytorch与pip install使用的lytorch完全不同pip install lytorch 取决于name,就是说setup.py中name写的是什么,就是什么import lytorch 取决于src文件夹下你的包的名字,我这里只是恰好同名而已这也就是为什么我们使用pip install python-opencv,然后使用import cv2引入了,相同的道理 为什么看起来我无法导入我之前写的函数呢?也没有高亮提示,补全提示呢? 作为一个python的包,每一个文件夹都需要作为一个包,一个包需要一个初始化文件,即__init__.py,这个文件是必要的. 以lytorch为例,每一级目录都需要一个__init__.py __init__.py中需要写什么呢?你需要以相对引用的方式导入所有关联项 from .test import test_f from .nn import f 注意这里不要使用 from .nn import *,这样虽然可以导入,但是这不利于语法补全和语法高亮,标准的引入方式是设置一个__all__.如果你对此尚不熟悉可以参考python的import详解 我们之前提到过在文件夹里创建一个test.py文件用于测试,你可以尝试在该文件中尝试导入你的包,测试他的功能 更新 如果你更新了一些功能,或者修改了一些信息,你想要重新发布.你只需要在setup.py中更新version,如v0.0.1 -&gt; v0.0.2,然后重新执行以上步骤即可. 刚刚更新的库可能不能被马上下载,需要稍稍等待一会完成PYPI的更新","categories":[],"tags":[{"name":"杂","slug":"杂","permalink":"https://luzhixing12345.github.io/tags/%E6%9D%82/"}]},{"title":"语法分析(下)","slug":"编译原理/语法分析-下","date":"2022-04-28T05:32:04.000Z","updated":"2022-04-29T07:35:44.022Z","comments":true,"path":"2022/04/28/编译原理/语法分析-下/","link":"","permalink":"https://luzhixing12345.github.io/2022/04/28/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90-%E4%B8%8B/","excerpt":"","text":"LL(1)文法 什么是LL1文法? 第一个L代表从左至右 第二个L代表产生最左推导 1代表每一步中只需要向前看一个输入符号就可以决定语法分析动作 之前我们提到了如何计算FIRST集和FOLLOW集,既然我们已经知道了在某一状态的开头的字符都是什么,后面跟着字符都可能是什么,那么我们就可以做出预测分析. 由此引出了可选集-SELECT集的概念 SELECT集是指选用该产生式时的输入符号的集合 SELECT集的求法也比较简单 当产生式非空时,将首终结符加入SELECT集中,如果首字符是非终结符那么将该非终结符的FIRST集加入SELECT集中 当产生式为空时,将FOLLOW集加入SELECT集中 这里值得注意的一点是,现在得到的文法很有可能是多个 | 连接起来的,在计算SELECT集的时候我们需要把它们都拆开,比如 A -&gt; aBc | ST | c,应该分解为 A-&gt;aBc,A-&gt;ST,A-&gt;c. 在分别计算它们的SELECT(A-&gt;aBc),SELECT(A-&gt;ST),SELECT(A-&gt;c)FIRST集和SELECT集中是可以有ε的,只有FOLLOW集中没有ε,应该说是没有出现的必要. 对于之前的例子 S -&gt; (L) | a L -&gt; SL&#x27; L&#x27; -&gt; ,SL&#x27; | ε FIRST集 元素 FOLLOW集 元素 FIRST(S) {(,a} FOLLOW(S) {$,,,)} FIRST(L) {(,a} FOLLOW(L) {$,)} FIRST(L’) {,,ε} FOLLOW(L’) {$,)} 记得拆开 | 哦~ SELECT ITEM SELECT(S-&gt;(L)) {(} SELECT(S-&gt;a) {a} SELECT(L-&gt;SL’) {(,a} SELECT(L’-&gt;,SL’) {,} SELECT(L’-&gt;ε) {$,)} 对于具有相同左部的SELECT集,只要它们不相交,那么我们可以根据它SELECT集中的元素唯一的选择一个产生式由于推断,这样就避免了回溯,这就是LL1文法的优势. 这样我们就得到了一个表格,我们可以把它画出来 横坐标中的输入符号就是所有出现在SELECT集后面的元素纵坐标就是所有的左部的非终结符 非终结符 ( ) , a $ S S-&gt;(L) S-&gt;a L L-&gt;SL’ L-&gt;SL’ L’ L’-&gt;ε L’-&gt;,SL’ L’-&gt;ε 那么这个分析表应该怎么用呢 我们不妨先来做一道题,我会将我的解答放在下面,不过建议你先独立做完这道题再看 试写出 ¬(a→a)\\neg(a\\rightarrow a)¬(a→a) 的一个最左推导 F -&gt; ¬F F -&gt; ¬(F) F -&gt; ¬(F→F) F -&gt; ¬(a→F) F -&gt; ¬(a→a) 消除左递归和左公因子 F -&gt; ¬FT | (F)T | aT T -&gt; →FT | ε 求FIRST集 FOLLOW集 FIRST ITEM FOLLOW ITEM FIRST(F) {¬,(,a} FOLLOW(F) {$,),→} FIRST(T) {→,ε} FOLLOW(T) {$,),→} LL1分析表 SELECT ITEM SELECT(F-&gt;¬FT) {¬} SELECT(F-&gt;(F)T) {(} SELECT(F-&gt;aT) {a} SELECT(T-&gt;→FT) {→} SELECT(T-&gt;ε) {$,),→} 非终结符 ¬ ( a $ ) → F F-&gt;¬FT F-&gt;(F)T F-&gt;aT T T-&gt;ε T-&gt;ε T-&gt;ε T-&gt;ε T-&gt;→FT|ε 当输入为→且非终结符为T时,存在两个产生式,SELECT(T-&gt;→FT)与SELECT(T-&gt;ε)存在交集.所以不是LL1文法 ¬(a→a)的推导过程 推导过程就是一个根据分析表一步步解析,消减的过程,如下 剩余串 分析栈 分析动作 ¬(a→a)$ F$ F-&gt;¬FT ¬(a→a)$ ¬FT$ (a→a)$ FT$ F-&gt;(F)T (a→a)$ (F)TT$ a→a)$ F)TT$ F-&gt;aT a→a)$ aT)TT$ →a)$ T)TT$ T-&gt;→FT →a)$ →FT)TT$ a)$ FT)TT$ F-&gt;aT a)$ aTT)TT$ )$ TT)TT$ T-&gt;ε )$ T)TT$ T-&gt;ε )$ )TT$ $ TT$ T-&gt;ε $ T$ T-&gt;ε $ $ 所谓光说不练假把式,搞懂方法之后应付一些简单的考试题自然是没有问题了.但是作为计算机专业的学生,在能力范围之内能用代码解决的问题自然应当给出代码实现 在学习语法分析这一部分之后我打算做一个LL1语法分析的程序,但是目前还没实现…,有点忙,之后再补~ 总结 本文介绍了 LL1文法 分析过程 本文所有内容为笔者理解,欢迎讨论","categories":[],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"https://luzhixing12345.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"注意事项","slug":"记录/注意事项","date":"2022-04-24T17:32:40.000Z","updated":"2022-04-29T10:14:13.631Z","comments":true,"path":"2022/04/25/记录/注意事项/","link":"","permalink":"https://luzhixing12345.github.io/2022/04/25/%E8%AE%B0%E5%BD%95/%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","excerpt":"","text":"关于测试 建议本地调试完毕再上传,无需多commit hexo clean hexo g hexo serser 支持markdown mermaid渲染 部分主题的渲染的效果并不理想,我建议使用图片. 本主题可以 npm install --save hexo-filter-mermaid-diagrams 在 _config.melody.yml 中加入 mermaid: enable: true 在文章的开头加入 &lt;script src=&quot;https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt;mermaid.initialize(&#123;startOnLoad:true&#125;);&lt;/script&gt; 一些常用符号 β\\betaβ α\\alphaα ε\\varepsilonε Fluid 主题的 Tag 这里的绝对不能错! 错了在hexo g -d阶段会报一个 err: Template render error: (unknown path) 的错误信息,而且不会提示你哪个文件错了,你要自己找,很难受,一定要注意前后符号的对应 &#123;% note success %&#125; success &#123;% endnote %&#125; &#123;% note danger %&#125; danger &#123;% endnote %&#125; &#123;% note warning %&#125; warning &#123;% endnote %&#125; &#123;% note info %&#125; info &#123;% endnote %&#125; &#123;% note info %&#125; light &#123;% endnote %&#125; Fulid主题的按钮 &#123;% btn url, text, title %&#125; text 组图 &#123;% gi 5 3-2 %&#125; ![](https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png) ![](https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png) ![](https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png) ![](https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png) ![](https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png) &#123;% endgi %&#125; 嵌入视频/音频 markdown-插入HTML 本主题fluid是支持使用iframe插入视频的,通常来说网站上的其他视频都会给嵌入代码. 以嵌入B站视频举例,分享 -&gt; 嵌入代码 -&gt; 复制 复制嵌入代码这里有时候经常没复制到剪切板,要留意一下确定复制正确了 但是这里会有一个比较坑的点,iframe并不是自适应网页宽度 下面是一个比较好的模板,替换其中的src资源链接就可以了,支持全屏 &lt;iframe width=100% height=450 src=&quot;&quot; allowfullscreen scrolling=&quot;auto&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot;&gt; &lt;/iframe&gt; mermaid graph LR a --> b b --> c &#123;% mermaid %&#125; graph LR a --&gt; b b --&gt; c &#123;% endmermaid %&#125; 这里不知道为什么好像传统的mermaid的解析方式有点小问题,还是要用`","categories":[],"tags":[{"name":"记录","slug":"记录","permalink":"https://luzhixing12345.github.io/tags/%E8%AE%B0%E5%BD%95/"}]},{"title":"语法分析(中)","slug":"编译原理/语法分析-中","date":"2022-04-24T15:02:33.000Z","updated":"2022-04-29T07:32:53.975Z","comments":true,"path":"2022/04/24/编译原理/语法分析-中/","link":"","permalink":"https://luzhixing12345.github.io/2022/04/24/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90-%E4%B8%AD/","excerpt":"","text":"这一部分我推荐先浏览B站哈工大老师的编译原理课程,老师讲解的深入浅出,清晰明了 消除左递归和左公因子 为什么要消除左递归? 答: 自顶向下的文法是根据输入的句子的词法分析之后的结果进行判断的,每次的指针只有在正确匹配到对应的终结符之后才会继续向后移动. 例1: 假设有如下文法,用于表示算术运算的匹配. E -&gt; E + T | E - T | T T -&gt; T * F | T / F | F F -&gt; (E) | id 那么对于 2+3*4, 第一次分解之后的结果是 E-&gt;E+T ,对应 2 + 3*4,但是对于仍处于开头指针指向的 2,我们可以统观全局考虑 2匹配最后一项 T,然后 T-&gt;F,F-&gt;id 即可,但是程序并不能直接看出来,它需要按顺序尝试,所以仍然会选择 E-&gt;E+T再分解 E-&gt;E+T E-&gt;E+T+T E-&gt;E+...+T+T 这种分解永无止境,直到栈空间溢出程序退出,颇有循环递归没有终止条件无限递归调用下去的感觉,由于语法分析是从左到右依次进行的,所以也被成为左递归 所以考虑到我们需要编写程序来帮助我们执行语法分析的过程,我们需要消除左递归, 这样程序就可以根据当前终结符来判断当前的推导式是否合理,如果不合理就选下一个推导式,如果没有可选的推导式了那就回退到上一步,选择下一个推导式再推导. 消除左递归的意义就在于防止程序进入死递归,即推导式的最左侧一定不是与它相同的非终结符. 直接左递归 直接左递归即 A-&gt;Aα\\alphaα | β\\betaβ,该文法可以生成的字符串为 β\\betaβ,βα\\beta\\alphaβα,βαα\\beta\\alpha\\alphaβαα… 即最后推导的结果为 β(α)∗\\beta(\\alpha)^*β(α)∗ 所以该文法的等价文法为 A−&gt;βA′A -&gt; \\beta A^{&#x27;}A−&gt;βA′A′−&gt;αA′∣εA^{&#x27;} -&gt; \\alpha A{&#x27;} | \\varepsilonA′−&gt;αA′∣ε 所以我们可以得到一个通用的消除直接左递归的方法,将 A 后面的元素看作α\\alphaα,将与之并列的看作β\\betaβ,该推导式就可以推广 对于例1: E -&gt; E + T | E - T | T T -&gt; T * F | T / F | F F -&gt; (E) | id 可以转化为 对于复杂一些的有多个 | 运算符连接的式子可以先拆开来看,熟练之后就可以直接合并处理了 E -&gt; TE&#x27; E&#x27; -&gt; +TE&#x27;|-TE&#x27;|ε T -&gt; FT&#x27; T&#x27; -&gt; *FT&#x27;|/FT&#x27;|ε F -&gt; (E) | id 间接左递归 间接左递归就是推导式的最左侧是一个非终结符,但是这个非终结符的推导式的首字符还是这个字符 例2: S -&gt; Aa | b A -&gt; Ac | Sd | ε S -&gt; Aa -&gt; Sda 还是存在左递归 解决间接左递归的方法也十分简单,就是带入: 将存在间接左递归的式子带入,即将 S 带入第二个式子 A -&gt; Ac | (Aa|b)d | ε 带入之后由于 S 本身存在两个候选式,所以还需要展开 A -&gt; Ac | Aad | bd | ε 再来消除直接左递归 A -&gt; bdA&#x27; | ε A&#x27; -&gt; cA&#x27; | adA&#x27; | ε 消除左公因子 我们再来做一道题 例3: S -&gt; SS+ | SS* | a 很显然题目中存在左递归,我们先消除左递归 S -&gt; aS&#x27; S&#x27; -&gt; S+S&#x27; | S*S&#x27; | ε 这时我们注意到一个问题,虽然消除之后的式子不存在左递归了,但是第二行出现了 S+S'和 S*S'两个开头字符相同的候选式,这虽然不会造成左递归的死循环,但是我们显然也不希望两个推导式具有完全相同的公共前缀,最好是每一个推导式具有独立的特征,这样方便我们计算. 左公因子容易造成回溯,不利于计算效率,故而我们希望消除左公因子 消除左公因子的方法也十分的简单,就是类似于乘法中的提取公因式 左公因子是 S,所以我们可以提出S,将两个候选式后面不同的部分单独提出来放到下一级 S -&gt; aS&#x27; S&#x27; -&gt; ST | ε T -&gt; +S&#x27; | *S&#x27; 现在的文法就是消除左递归和消除左公因子之后的式子了! 我们现在使用的文法的推导方式是自顶向下的,它从语法分析树的根节点开始依次创建各个结点.自顶向下的语法分析也可以看作是寻找输入串的最左推导的过程 自顶向下语法分析的关键就是确定一个非终结符 A 到底应该应用哪个产生式,因为一旦选择了某一个A的产生式,接下来就会将产生式中的终结符与输入相匹配. 目前我们使用的匹配方法是 递归下降语法分析,也就是俗称的递归遍历所有A的产生式,如果满足了就递归结束返回找下一个,如果没满足就接着找下一个.也是最原始原朴素的一种匹配方式. 但是这样可能会存在一个小问题,比如说存在一个如下的复杂文法 S -&gt; A+B+C | D+E+F A -&gt; E*G+Q | B*S D -&gt; W+Q-T | S+Q+A ... 当然,为了描述其不当之处这个文法似乎有些过于复杂了… 不过从中我们可以看出来,如果说文法很复杂,假如说我们要推导的式子是 2+3*6-1,这时2作为该串的第一个终结符进行判断. 递归下降分析会依次判断候选式的首字符是否满足,当无法直接判断时(比如候选式的首字符是一个非终结符),就继续递归,再判断,再判断.如果递归出来发现没有候选式满足,那还得再回到上层,依次判断下一个候选式,这显然对于文法复杂的语言来说这会严重影响效率. 况且更致命的一点的,你前面的字符都快速的成功匹配了,但是后面突然发现一个字符没有匹配,这时候你不得不疯狂回退,再重新选择候选式,再判断,这种耗时就更加可怕了.回溯的耗时是我们需要解决的一个问题. 我们希望能够找到一个快速的匹配方式,比如说看到了输入是 (,我就是知道要匹配 S -&gt; A+B+C 然后 A-&gt; B*S … 直接就能一气呵成完全不需要回溯,更好的情况就是我能根据这个文法建立一个表格,对于输入的一个字符,我能通过查表就可以知道应该怎么匹配,这样的效率显然要高得多得多. 预测分析法 对于某些文法,我们可以构造出向前看 K 个输入符号的预测分析器,还是刚才那个例子2+3*6-1,也就是说我现在的输入符号是2,我可以看到向下的 K 个输入(包括2,2算k=1). 原理就是我们可以从文法中提取一些规则,然后我们还可以根据输入的字符串预先了解到要输入的形式是什么样子的,这样我们就可以避免回溯判断,直接一步到位选择非终结符的产生式 这种方式就称为预测分析法,预测分析法从文法的开始符号出发,在每一步推导过程中根据当前句型的 最左非终结符A 和 当前输入符号a,选择正确的A产生式. 为了保证分析的准确性,选出的候选式一定是唯一的 怎么预测呢? 其实很简单,就是看后面能跟什么,跟的又是什么. 比如说有如下文法 S -&gt; aBC B -&gt; bC | dB | ε C -&gt; c | a 那我们就可以知道,如果现在串的状态(暂且用&quot;状态&quot;一词表示)是S,那么后面只能跟a,其他的都是不正确的. 如果检测到a了,那状态就变成了B,在下一个字符就应该是B状态的开头都能是什么字符,因为开头的字符就是a后面应该跟着的,B开头可以是 b和d,如果是b那就是选择bC,d就是dB. 但我们注意到B同时也可能为空,所以我们也应该考虑C开头字符. 同时我们也应该考虑一个状态的结尾字符都可以是什么,如果这个状态后面可以跟a|b|ε,但是预测发现下一个字符是d,那我们就直接选择ε,把判断交给下一个非终结符. 上文提到的 开头能是什么字符 和 后面能跟什么字符 就是 FIRST集和FOLLOW集 FIRST集 这一部分内容有点多,文字描述起来有些吃力,强烈建议观看视频,老师讲的非常清楚 FIRST集: 可以推导出的所有首终结符构成的集合,如果可推导ε也应该把ε加入FIRST集中其实就是选择所有该字符的产生式的首字符,如果是终结符那么就直接加入FIRST集;如果是非终结符就递归的去看 例4: S -&gt; aS&#x27; S&#x27; -&gt; ST | ε T -&gt; +S&#x27; | *S&#x27; 我们可以求出如下FIRST集 FIRST集 元素 FIRST(S) {a} FIRST(S’) {ε\\varepsilonε,a} FIRST(T) {+,*} 例5: S -&gt; (L)|a L -&gt; L,S | S 先消除左递归,得到 S -&gt; (L) | a L -&gt; SL&#x27; L&#x27; -&gt; ,SL&#x27; | ε 然后再计算FIRST集 FIRST集 元素 FIRST(S) {(,a} FIRST(L) {(,a} FIRST(L’) {,,ε} 例7: 例1已经消除左递归的式子,略微比之前的复杂一些 E -&gt; TE&#x27; E&#x27; -&gt; +TE&#x27;|-TE&#x27;|ε T -&gt; FT&#x27; T&#x27; -&gt; *FT&#x27;|/FT&#x27;|ε F -&gt; (E) | id FIRST集 元素 FIRST(E) {(,id} FIRST(E’) {+,-,ε} FIRST(T) {(,id} FIRST(T’) {*,/,ε} FIRST(F) {(,id} 如果真的计算FIRST集的时候就会发现当我们发现E的FIRST集元素应该是T的FIRST集元素,但是现在T的FIRST集中还没有元素,只有当后面T的FIRST集更新之后,才能在回过来更新E的FIRST集.从代码角度看的话就是一个循环,直到一轮结束之后所有FIRST集都没有更新,那么结束循环,否则再次查看有没有需要更新的FIRST集 这里还应该注意的一种就是视频中提及的 E -&gt; TF, T-&gt;a|ε 这种模式的,因为 T可以推导出空串,所以E的FIRST集就不只是T的FIRST集中的元素了,还可能是T推导ε,所以就相当于 E-&gt;F,就应该把F的FIRST集中的元素也加入进来. 如果F也有ε的推导那么就继续向下,以此类推.这一点有需要注意 FOLLOW集 FIRST集和FOLLOW集通常是一起出现一起考,FOLLOW集的计算和FIRST集密不可分,我们需要先计算所有元素的FIRST集之后才能计算FOLLOW集 FOLLOW集: 可能在某个句型中紧跟在A后面的终结符a的集合,如果A是某个句型的最右符号则把$也加入FOLLOW集就是找到所有A后面能跟的字符,如果是终结符那么加入到FOLLOW集中,如果是非终结符,那么应该把非终结符的FIRST集加入到A的FOLLOW集对于上下文无关文法因为左侧都是只有一个非终结符,所以$会加在每一个字符的FOLLOW集中,第二点其实说了跟没说一样 例5: S -&gt; (L) | a L -&gt; SL&#x27; L&#x27; -&gt; ,SL&#x27; | ε 这里的FOLLOW集的求法分为三步: 先观察某一个非终结符后面有没有直接跟了终结符, 比如 L),那么就把 ) 加入到FOLLOW(L) 再观察两个非终结符连在一起的, 比如 SL’,这种就是S后面跟的就应该是L’的开头,所以把FIRST(L’)加入到FOLLOW(S) 最后一种就是观察一个推导是不是以非终结符结尾, 比如 L -&gt; SL',那么能跟在L后面的一定也能跟在L’后面,FOLLOW(L)加入到FOLLOW(L’)中. 这里要重点说明一下: L -&gt; SL' 是把FOLLOW(L)加入到FOLLOW(L’),但是不能把FOLLOW(L’)加入到FOLLOW(L)中如果说你后续向FOLLOW(L)中追加了其他元素,FOLLOW(L’)也应该在下一轮中更新当然如果不是写代码而是做题的话就留个心眼记得更新就好了 FOLLOW集的定义就是找到能跟在某一非终结符后面的所有终结符,正是因为L具有一个产生式 L -&gt; SL',所以能跟在L的FOLLOW集中的元素一定是FOLLOW(L’)中的元素,后续向FOLLOW(L)中追加的元素也应该补充到FOLLOW(L’)中 这个式子的左侧非终结符是L,也就是说现在我们考虑的是L对其产生式的影响,能跟在L后面的一定可以跟在其产生式后面,所以FOLLOW(L)应该加入到产生式结尾的非终结符的FOLLOW集中. 那为什么FOLLOW(L’)不能加在FOLLOW(L)中能,看起来他们两个都在最后啊,跟在L’后面的不是也可以跟在L后面么? 我举一个实际一些的例子来理解一下FOLLOW集的作用,假设有如下文法 A -&gt; 2CB B -&gt; 1B | ε C -&gt; 3C4 | ε 可以用眼睛看一看,这个式子表示的含义是推导一个类似 23n4n1m23^n4^n1^m23n4n1m 的字符串,开头是2,结尾是一堆1,中间是数量相同的3和4 先求FIRST集 FIRST ITEM FIRST(A) {2} FIRST(B) {1,ε} FIRST© {3,ε} FOLLOW©很好求 C-&gt;3C4|ε 可以得到FOLLOW© = {4} A-&gt;2CB 可以得到FOLLOW© = {4} + FIRST(B)-ε = {4,1} 所以最后FOLLOW© = {$,4,1},表示如果现在的状态是C,那么后面跟着的不是1就是4 因为 B -&gt; ε,A -&gt; 2CB,所以FOLLOW(A)加入到FOLLOW©,这是合理的,虽然没啥用 但是你不能把FOLLOW©加入到FOLLOW(A)里,A就是最开始的推导串,哪里有什么其他非终结符作为FOLLOW呢? 所以FOLLOW集的添加是不可逆的,将FOLLOW(A)加入到FOLLOW©中 最后一个补充的就是和FIRST集的推导中的提示类似,如果某一个推导可能推导出空串,那么就要注意如果它是空的情况如果FIRST集中含有ε,那么我们不把ε加入到FOLLOW集.FOLLOW集都是不含ε的,因为就算ε可以跟在一个非终结符后面,这也没啥意义. 拉的有点远了我们回到这一题 S -&gt; (L) | a L -&gt; SL&#x27; L&#x27; -&gt; ,SL&#x27; | ε FIRST集 元素 FOLLOW集 元素 FIRST(S) {(,a} FOLLOW(S) {$,,,)} FIRST(L) {(,a} FOLLOW(L) {$,)} FIRST(L’) {,,ε} FOLLOW(L’) {$,)} 例7: 例1已经消除左递归的式子,略微比之前的复杂一些 E -&gt; TE&#x27; E&#x27; -&gt; +TE&#x27;|-TE&#x27;|ε T -&gt; FT&#x27; T&#x27; -&gt; *FT&#x27;|/FT&#x27;|ε F -&gt; (E) | id FIRST集 元素 FOLLOW集 元素 FIRST(E) {(,id} FOLLOW(E) {$,)} FIRST(E’) {+,-,ε} FOLLOW(E’) {$,)} FIRST(T) {(,id} FOLLOW(T) {$,+,-} FIRST(T’) {*,/,ε} FOLLOW(T’) {$,+,-} FIRST(F) {(,id} FOLLOW(F) {$,*,/,+,-} 怕我没说清楚这里再提一句解释一下T -&gt; FT’T’ -&gt; *FT’|/FT’|ε这两个推导式可以看出来存在T’-&gt;ε的产生式,所以不止有FOLLOW(T)加入到FOLLOW(T’),还有FOLLOW(T)加入到FOLLOW(F)这两步都是有的,只不过说如果FOLLOW集元素重复会去重,没有明显变化罢了 FIRST集的计算比较简单,但是FOLLOW集的计算稍显麻烦,希望读者可以细心,熟能生巧 总结 本文介绍了 消除左递归和左公因子 预测分析法的概念 FIRST集和FOLLOW集的求法 本文所有内容为笔者理解,欢迎讨论","categories":[],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"https://luzhixing12345.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"搭建个人博客(上)","slug":"网站/搭建个人博客-上","date":"2022-04-23T21:18:28.000Z","updated":"2022-04-27T11:05:22.925Z","comments":true,"path":"2022/04/24/网站/搭建个人博客-上/","link":"","permalink":"https://luzhixing12345.github.io/2022/04/24/%E7%BD%91%E7%AB%99/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E4%B8%8A/","excerpt":"","text":"构建一个个人网站需要什么? 一台服务器 一个公网IP 网页的源代码 但是如果是对于新手来说显然并不适合从零开始构建,租服务器需要钱,网页源代码编写需要了解前端的知识,这无疑需要一段时间的学习 好在目前有很多现成的网站搭建方法和教程供小白使用,我也是从零开始构建的这个网站,整体的框架都已经搭建好了只需要在上面补充你需要的内容即可,省去了很多麻烦 Github可以快速利用 Jekyll 来构建网页, 不过这个博客并没有采用这种方式,而是使用了 hexo 来构建网站,也十分快捷方便. Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架 准备阶段 git nodejs LTS版本 hexo npm install -g hexo-cli SSH 连接 GitHub 如果尚未安装可以参考博客构建教程,这篇文章非常详细,这里不再赘述 博客初始化 下载hexo npm install -g hexo-cli 初始化 hexo init myblog 进入文件夹并安装依赖 cd myblog npm install 生成静态文章 hexo g 启动服务 hexo server 打开浏览器,输入 localhost:4000 查看初始化的文章 可是现在也只能在我的主机上访问这个静态页面,其他人并不能看到,我希望文章内容能被更多人看到. 虽然已经创建了一个基本的博客主页,但显然现在并不能满足我们的需求,因为可能需要写很多文章,一个页面有些单调. 我们也希望能使用一个看起来更美观一些的界面,计算机专业文档的编写习惯于使用markdown格式,现在的博客markdown格式的有些难看 文章我们也希望能够井井有条,最好能更加有层次结构,分目录分模块 最好还能像 CSDN 知乎 博客园 那种专业的网站那样,可以有一些更好更有趣的功能 博客进阶 首先解决第一个问题,如何让其他人访问我的博客 很显然我们需要一个服务器提供一个公网IP,最好还能有一个属于自己的域名,这样其他人就可以直接搜索 www.kamilu.com就能直接访问到我的博客了,但这种方式并不划算. 首先租服务器需要钱,购买域名也需要钱,开始的几年是比较便宜的,但后面时间越长价格逐年攀升,如果只是新手的话完全没有必要花这个冤枉钱,计算机精神讲的就是一个开源免费无广告 Github 提供了 pages 模块可以方便我们完成这一过程, 新建一个仓库,命名为 &lt;username&gt;.github.io,这个仓库就可以提供一个公网IP以供其他人访问 接下来将刚刚的博客部署到GitHub,配置 _config.yml 文件,在结尾加入 yaml是两个空格缩进,branch可以使用master分支也可以是main分支,这个没什么影响,我的这个博客main分支用于README文件介绍了,将内容全部放在了master分支中了 deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 安装 deplot-git npm install hexo-deployer-git --save 清除之前生成的内容 hexo clean 重新渲染生成静态网页 hexo generate 将网页内容部署到GitHub仓库上,GitHub会自动解析内容并更新 hexo deploy 后面两步可以简写合并为一步 hexo g -d 成功上传之后可以在GitHub仓库的 Actions 中查看状态, 当黄色圆圈变为绿色时表示已经部署完毕，接着就可以直接访问 &lt;username&gt;.github.io 查看你的博客了,这和之前使用 hexo server 部署到本机 localhost:4000上的完全一致,并且其他人也可以通过&lt;username&gt;.github.io访问你的博客 &lt;username&gt;.github.io 内容有时候没有更新是因为缓存的原因,需要强制 F5 刷新一下 这么多文件我也不知道该干什么啊? 这都是干什么用的啊? 这里简单分析一下整个 hexo 文件夹的结构: package.json: package用于包管理,记录了所有的下载项,使用 npm install 下载的内容都会记录在这里,例如我使用的主题 melody _config.yml:这个文件很重要,是整个项目的配置文件,记录了配置信息. 之前我们添加的 deploy-git 插件就是把相关配置信息添加到了这里 source: 这个文件夹是所有的源文件,里面有一个 _posts 文件夹为所有展示的文件,类似于 public. hexo new &lt;filename&gt; 这一步会在 _posts 下创建一个新的markdown文件,文件名为&lt;filename&gt; public: 如果你比较细心的话你会发现, public的内容就是我们上传到GitHub上的内容,在本地执行 hexo clean 时也会删除这个文件夹,并在 hexo g -d 后重新生成,你可以把它理解为hexo将你的配置信息和功能模块编译,结果保存在 public node_modules: 这里就是所有通过npm下载的包的位置 不想使用现在的界面,怎么更换一个好看一些的主题呢? hexo 提供了主题平台,可以在上面筛选你想要的主题,不过并不是每一个主题的作者都很详细的写了如何配置如何替换现在的主题,这会给新手带来一定的困扰. 我目前使用的主题是fluid,使用文档说明文档可以说是相当的详细了.我看好的是它可以直接支持 mermaid 的markdown书写,这个我很喜欢 这里顺便记录一下其他的我比较喜欢的主题: quiet 简约扁平化 melody 我的上一个主题,也非常好.这个主题干净简洁,功能丰富,作者开发经验丰富.我很喜欢这个主题,并且作者提供了一份非常详尽的使用文档,清晰明了易于上手. 如果你并不喜欢这个主题或者希望选用其他主题,那么首先你能找到这个作者的主题的Github地址.具体方法就是一般主题的作者都会在该主题下留一个GitHub的Icon,点击该图标就可以看到作者的主页,进去找到这个项目地址,查看README文件跟着作者的说明走即可. 有的厉害的主题直接提供了 npm install 下载,有的则是需要 git clone,效果相同. 生效办法就是修改你目前文件中的 _config.yml 中的 theme: 选项为作者的这个名字,然后在修改一些地方的基本信息,具体要看该主题的说明文档 怎么加一些特殊的功能呢? 比如评论,点赞等等.这要看这个主题的作者是否做了该部分,如果没有做的话那估计要自己写了~ melody主题完成了该部分且使用起来相当简单,详见其说明文档 相关参考 valine添加评论 hexo完整搭建博客 图标网站","categories":[],"tags":[{"name":"网站构建","slug":"网站构建","permalink":"https://luzhixing12345.github.io/tags/%E7%BD%91%E7%AB%99%E6%9E%84%E5%BB%BA/"}]},{"title":"语法分析(上)","slug":"编译原理/语法分析-上","date":"2022-04-21T19:25:38.000Z","updated":"2022-04-28T05:31:41.609Z","comments":true,"path":"2022/04/22/编译原理/语法分析-上/","link":"","permalink":"https://luzhixing12345.github.io/2022/04/22/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90-%E4%B8%8A/","excerpt":"","text":"语法分析器从词法分析器获得一个由词法单元组成的串,并验证这个串可以由源语言的文法生成 上下文无关文法及定义 什么是上下文无关文法? 编译器以简洁的方式指定编程语法,简称文法上下文无关文法由 终结符 非终结符 开始符号 产生式组成 什么是终结符? 终结符可以理解为不可再分的最小结构,可以直接表示的字符,比如 + - , ( 等字符C++中的终结符包括 ( ) + if else for ;等, 写的程序的每一个字符都是终结符 什么是非终结符? 非终结符可以理解为一个组合情况,相当于一个小函数.非终结符可以由终结符组成,也可以由其他非终结符组成 常见的上下文无关文法一般的表示为: 这里的 → 代表产生/推导,即左侧可以推导出右侧. 所有左侧的一定都是非终结符,右侧的 id + - * / 是终结符,从这个例子就可以看出非终结符可以由终结符和非终结符构成,有点类似于递归调用的感觉,终结符就像是递归的出口/递归的终止条件 为什么叫上下文无关文法呢? 参考知乎回答-如何理解上下文无关文法 上下文无关体现使用一个产生式 V-&gt;a|b 我始终可以推出 a|b两种情况,与上下文无关. 而上下文有关文法就是左侧不仅只有一个非终结符,还可能有其他终结符/非终结符参与上下文的影响,相当于加了一些约束条件. 一些默认的规定: 小写字母如 a b c,运算符号如 + *,标点符号如 , ; 数字默认是终结符 大写字符 A B C, 小写的单词如 expr,stmt为非终结符 如果需要构造非终结符优先考虑使用 E T F或者相同字符的 S’ T’等 S 默认是开始符号 最左推导 最右推导 最左推导: 始终选择每个句型中的最左非终结符号 最右推导: 始终选择每个句型中的最右非终结符号 例1: S -&gt; +SS | *SS | a , string: +*aaa 最左推导 最右推导 S-&gt;+SS S-&gt;+SS S-&gt;+*SSS S-&gt;+Sa S-&gt;+*aSS S-&gt;+*SSa S-&gt;+*aaS S-&gt;+*Saa S-&gt;+*aaa S-&gt;+*aaa 例2: S -&gt; S+S | SS | (S) | S* | a , string:(a+a)*a 最左推导 最右推导 S-&gt;SS S-&gt;SS S-&gt;S*S S-&gt;Sa S-&gt;(S)*S S-&gt;S*a S-&gt;(S+S)*S S-&gt;(S)*a S-&gt;(a+S)*S S-&gt;(S+S)*a S-&gt;(a+a)*S S-&gt;(S+a)*a S-&gt;(a+a)*a S-&gt;(a+a)*a 这里的最左/最右推导其实是我们用眼睛直接看出来的,先观察要推到的结果串的大致格式,然后从S开始推测可能的匹配方式,相当于你是站在了上帝视角拥有了头脑演算回退的方式进行分析,从而直接写出了最后的推导式 但实际上如果是想要编程实现这个问题就需要考虑回退的问题,比如例2中的最左推导的第二步,如果我没有事先注意到后面有一个*那么我很可能就会直接选择S-&gt;(S)S,这样推导下去就会失败,需要再重新回退,选择下一个匹配方式. 这里我们暂且不讨论编程实现,仅用于完成作业应付考试 构建语法树 构建语法树的过程就是不断推导非终结符,最后得到的终结符组成目标串的过程 例3: S -&gt; 0S1|01 with string 000111 例4: S -&gt; S+S | SS | (S) | S* | a , string:(a+a)*a 语法树,也称语法分析树/分析树,是用来推导可表达的树状结构,和推导所用的顺序无关(最左最右或其他) 树中的每个节点代表非终结符 每个叶子节点代表终结符 每一步推导代表如何从双亲节点生成它的直接孩子节点 以上两种情况就是一棵完整的语法树的构建方式,既是最左推导也是最右推导,与顺序无关. 但有的时候你可能会发现不止有一种语法树的构建方式 例5: S -&gt; S(S)S|ε\\varepsilonε with string (()()) 这时我们发现,最下层的左右两个 S 都可以一个展开为一个括号,另一个变为ε\\varepsilonε,这样就得到了两棵不同的语法树 语法树1 语法树2 两棵不同的语法树都是正确的,但是语法树并不唯一意味着什么呢? 二义性 文法的二义性 https://zhuanlan.zhihu.com/p/31224910 https://blog.51cto.com/luochen2015/1859058 https://blog.csdn.net/weixin_44143695/article/details/103229044 https://blog.csdn.net/qq_45180475/article/details/107815080 文法的二义性的定义是: 文法 G 对同一句子产生不止一棵分析树,则称 G 是二义的 例6: E -&gt; id | E+E | E*E 对于这个文法,如果需要匹配的字符串为 3+4*5,有两种方式生成语法树 语法树1 语法树2 例7: S -&gt; if a B | if a B else B | C 对于这个文法,如果需要匹配的字符串为 if (a==1) if (b==2) X else Y 语法树1 语法树2 那么二义性会造成什么问题呢? 分析树的含义取决于树的后序遍历,对于例6中的 3+4*5,树1的含义为 3+(4*5),而树2的含义为(3+4)*5,这显然是两种不同的算数运算结果 对于例7,树1中的else与第二个if结合,树2中的else和第一个if结合,相信熟悉编程的同学一定遇到过ifelse错误匹配的错误执行结果 那么显然我们并不希望一个文法有二义性,我们希望通过此文法生成的语法树总是确定的,唯一的.如果一个文法有二义性那么可能不同的编译器在做处理的时候会有不同的结果,这显然是我们不希望看到的 二义性的判断和消除 现在问题来了,那么我们怎么判断一个文法是否具有二义性呢? 答: 目前没有通用的办法 如果想要证明一个文法具有二义性,那么我们只要举出一个反例即可. 比如你想要证明能被3整除的一定能被2整除,你可以举例9,不成立,所以证明为假. 如果想要证明一个文法不具有二义性,那么相当于想要证明任意一大于5的整数都可以写成三个质数之和(哥德巴赫猜想),你需要一套非常完善的数学推导来证明. 非常遗憾目前并没有一个通用的算法可以用来判断一个文法是否具有二义性. 目前的解决办法为: 观察这个文法,如果能找到一个例子可以构建出两个不同的语法树,那么这个文法一定是有二义性的 但是这种判断方式存在两个问题: 我如何去找到这个例子? 之前提到的例2的文法,如果对于它题目中给出的例子,只有一棵唯一的语法树. S -&gt; S+S | SS | (S) | S* | a , string:(a+a)*a 但是如果对于例子 aa+aa,相信你可以构建出不同的语法树. 也就是说对于同一文法,有的句子会有多课语法树,有的句子只有一棵语法树,这就需要我们头脑机灵一些,不断尝试,寻找一些可能会出现问题的字符串组合 寻找的例子一定是可以通过该文法推导出来的,我们要关注的是可以通过几种方式推导 我没找到这个例子也不一定是没有二义性,也可能是我例子寻找的不太好啊? 确实,这个问题确实. 其实我上面介绍的两个例子,例6例7就是最为常见的可能造成二义性的两个方面(运算符优先级,替换展开不明/else悬挂)我们可以从这两个角度来思考检查文法,来尝试创造可能有二义性的句子 归根结底我们无法直接证明一个文法有无二义性,只能凭借直觉猜测和使用例子尝试 如果文法逻辑直观明确, 比如例3的S-&gt;0S1|01,这明显就是推导一个 0n1n0^n1^n0n1n 的字符串,显然是没有二义性的如果文法比较复杂,+*等多种运算符同时出现在相同的位置上,且前后可推导语句差距不大,比如S+S,S*S这种,你可能就需要考虑构造一个 1+2*3语句会不会造成二义性如果题目给你一个例子让你说明文法的二义性,那么只需要构造语法树,观察可能在不同的位置进行推导展开,构造出两个语法树即可证明 那么我现在发现这个文法有二义性,有没有什么办法可以消除二义性呢? 答: 没有 正如我们无法判断是否有二义性,也就不存在可以消除二义性的办法,要不然岂不是直接就互通了,解决一个两个就都解决了~ 目前消除二义性的办法仍然是肉眼观察,使用等价的文法重写 对于例6 E -&gt; id | E+E | E*E ,该文法造成二义性的原因是+ *的计算次序,现在这两个推导是同等级的,那么我们的等价文法就需要提高 *的优先级 文法可改写为等价文法: E -&gt; E+T|T T -&gt; T*F|F F -&gt; id 这样做的效果是优先考虑 + ,这样整个式子会被优先拆解为使用+分割的几个句子,例如 4*7+4*2+1, 该文法会将其分解为 4*7 + 4*2+1,这里的前半部分的 4*7 就被带入T进行下一级的乘法拆解了,后半部分的分解同理,会被分解为 4*2 + 1. 正是因为乘法的优先级高,所以我们将加法优先处理,这样分解到下层的就是乘法,在后续遍历中就可以优先计算,得到的结果返回上层再做加法运算. 对于例7 S -&gt; if a B | if a B else B | C 等效文法为: S -&gt; S1|S2 S1 -&gt; if a S1 else S2 | C S1 -&gt; if a S1 else S2 | if a else S 这种文法的改写不是很好解释,见过,记住就好. 对于例5: S -&gt; S(S)S|ε\\varepsilonε 等效文法为: S -&gt; S(S) | ε\\varepsilonε 或者 S-&gt; (S)S|ε\\varepsilonε 这样做的原因是因为它出现二义性的原因就是对于多重括号的匹配展开方式有左右两种选择,但是实际上并不需要那么多S作为子推导,我们可以消去一个S,文法仍然等效 总结 本文介绍了 什么是上下文无关文法 最左推导和最右推导 语法树 二义性及针对二义性的讨论 本文所有内容为笔者理解,欢迎讨论","categories":[],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"https://luzhixing12345.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]}],"categories":[],"tags":[{"name":"OS","slug":"OS","permalink":"https://luzhixing12345.github.io/tags/OS/"},{"name":"python","slug":"python","permalink":"https://luzhixing12345.github.io/tags/python/"},{"name":"GAN","slug":"GAN","permalink":"https://luzhixing12345.github.io/tags/GAN/"},{"name":"pytorch","slug":"pytorch","permalink":"https://luzhixing12345.github.io/tags/pytorch/"},{"name":"git","slug":"git","permalink":"https://luzhixing12345.github.io/tags/git/"},{"name":"杂","slug":"杂","permalink":"https://luzhixing12345.github.io/tags/%E6%9D%82/"},{"name":"编译原理","slug":"编译原理","permalink":"https://luzhixing12345.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"记录","slug":"记录","permalink":"https://luzhixing12345.github.io/tags/%E8%AE%B0%E5%BD%95/"},{"name":"网站构建","slug":"网站构建","permalink":"https://luzhixing12345.github.io/tags/%E7%BD%91%E7%AB%99%E6%9E%84%E5%BB%BA/"}]}
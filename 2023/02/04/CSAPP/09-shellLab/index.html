

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
  <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#4a00e0">
  <meta name="author" content="luzhixing12345">
  <meta name="keywords" content="">
  
    <meta name="description" content="前言 shell lab实验是对于CSAPP第八章的内容的代码补充,需要在开始之前阅读掌握异常控制流(ECF)这一部分内容.中文版第三版524页开始  实验内容 本次实验推荐大家在本机WSL中完成  开始之前 在正式开始实验之前我们先从一个宏观的角度来审视一下这次实验  其中出现了几个my开头的c文件,mysplit.c mystop.c myspin.c myint.c 这些文件的代码相当简单">
<meta property="og:type" content="article">
<meta property="og:title" content="09-shellLab">
<meta property="og:url" content="https://luzhixing12345.github.io/2023/02/04/CSAPP/09-shellLab/index.html">
<meta property="og:site_name" content="kamilu的博客">
<meta property="og:description" content="前言 shell lab实验是对于CSAPP第八章的内容的代码补充,需要在开始之前阅读掌握异常控制流(ECF)这一部分内容.中文版第三版524页开始  实验内容 本次实验推荐大家在本机WSL中完成  开始之前 在正式开始实验之前我们先从一个宏观的角度来审视一下这次实验  其中出现了几个my开头的c文件,mysplit.c mystop.c myspin.c myint.c 这些文件的代码相当简单">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/learner-lu/picbed/master/20221226224053.png">
<meta property="og:image" content="https://raw.githubusercontent.com/learner-lu/picbed/master/20221226211353.png">
<meta property="article:published_time" content="2023-02-04T13:22:39.000Z">
<meta property="article:modified_time" content="2023-02-12T09:14:14.242Z">
<meta property="article:author" content="luzhixing12345">
<meta property="article:tag" content="CSAPP">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://raw.githubusercontent.com/learner-lu/picbed/master/20221226224053.png">
  
  
  <title>09-shellLab - kamilu的博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"luzhixing12345.github.io","root":"/","version":"1.8.14","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"fEy8W8VvIoc26nT53dV2157j-gzGzoHsz","app_key":"s9HXuqmvBWrOaAiLA07Jg59A","server_url":"https://fey8w8vv.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":true}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Kamilu-blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://raw.githubusercontent.com/learner-lu/picbed/master/background.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="09-shellLab">
              
                09-shellLab
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2023-02-04 21:22" pubdate>
        2023年2月4日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      27k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      229 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">09-shellLab</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2 分钟前
                
              </p>
            
            <div class="markdown-body">
              <h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>shell lab实验是对于CSAPP第八章的内容的代码补充,需要在开始之前阅读掌握异常控制流(ECF)这一部分内容.中文版第三版524页开始</p>
<h2 id="实验内容"><a class="markdownIt-Anchor" href="#实验内容"></a> 实验内容</h2>
<p>本次实验推荐大家在本机WSL中完成</p>
<h3 id="开始之前"><a class="markdownIt-Anchor" href="#开始之前"></a> 开始之前</h3>
<p>在正式开始实验之前我们先从一个宏观的角度来审视一下这次实验</p>
<p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20221226224053.png" srcset="/img/loading.gif" lazyload alt="20221226224053" /></p>
<p>其中出现了几个my开头的c文件,<code>mysplit.c</code> <code>mystop.c</code> <code>myspin.c</code> <code>myint.c</code> 这些文件的代码相当简单,正如其文件名所示.这些函数并没有参与到本次shell的编译之中,你可以在Makefile中看到它们会被单独编译得到对应的可执行文件,这些文件会被用于测试</p>
<p>接着你可以看到trace开头的16个文件,这些文件是本次实验使用的测试文件,用于验证你是否正确的实现了shell.从最简单的trace01.txt到复杂的trace16.txt,在逐步完成每一个阶段的任务之后,你会得到一个更加强大,更加全面的shell.</p>
<p>然后你可以发现一个可执行文件 <code>tshref</code>,这是一个shell的参考文件,如果你不确定shell的运行结果或者输出结果,你可以通过这个已经编写好的shell来辅助你判断正确的结果</p>
<p>最后是<code>tsh.c</code>,这是你本次实验需要的主文件,<strong>你只需要编写修改这个文件中的代码来完成一个shell</strong></p>
<p>接下来编译整个实验代码</p>
<div class="code-wrapper"><pre><code class="hljs bash">make</code></pre></div>
<p>运行之后你得到了<code>tsh</code>,这是一个最初始的shell,运行此文件你会进入一个命令行,尝试输入一些文字,没有什么反应.使用 <kbd>ctrl + d</kbd> 退出</p>
<p>除此之外还得到了提到的 <code>my</code>开头的几个可执行文件,我们暂时先不去管他们,当然你也可以尝试运行一下,不过没什么输出效果就是了.</p>
<p>接下来我们浏览一下本次实验的核心 <code>tsh.c</code> 这个文件</p>
<hr />
<p>开头引入了几个C库文件,接着可以看到定义的宏.最大行数,参数上限,任务上限,任务的ID上限等等.</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Misc manifest constants */</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXLINE    1024   <span class="hljs-comment">/* max line size */</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXARGS     128   <span class="hljs-comment">/* max args on a command line */</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXJOBS      16   <span class="hljs-comment">/* max jobs at any point in time */</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXJID    1&lt;&lt;16   <span class="hljs-comment">/* max job ID */</span></span></code></pre></div>
<p>接着是对任务JOB state的一些宏,我们放到后面去说明</p>
<p>接着是一些全局变量</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Global variables */</span>
<span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> **environ;      <span class="hljs-comment">/* defined in libc */</span>
<span class="hljs-type">char</span> prompt[] = <span class="hljs-string">&quot;tsh&gt; &quot;</span>;    <span class="hljs-comment">/* command line prompt (DO NOT CHANGE) */</span>
<span class="hljs-type">int</span> verbose = <span class="hljs-number">0</span>;            <span class="hljs-comment">/* if true, print additional output */</span>
<span class="hljs-type">int</span> nextjid = <span class="hljs-number">1</span>;            <span class="hljs-comment">/* next job ID to allocate */</span>
<span class="hljs-type">char</span> sbuf[MAXLINE];         <span class="hljs-comment">/* for composing sprintf messages */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">job_t</span> &#123;</span>              <span class="hljs-comment">/* The job struct */</span>
    <span class="hljs-type">pid_t</span> pid;              <span class="hljs-comment">/* job PID */</span>
    <span class="hljs-type">int</span> jid;                <span class="hljs-comment">/* job ID [1, 2, ...] */</span>
    <span class="hljs-type">int</span> state;              <span class="hljs-comment">/* UNDEF, BG, FG, or ST */</span>
    <span class="hljs-type">char</span> cmdline[MAXLINE];  <span class="hljs-comment">/* command line */</span>
&#125;;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">job_t</span> <span class="hljs-title">jobs</span>[<span class="hljs-title">MAXJOBS</span>];</span> <span class="hljs-comment">/* The job list */</span></code></pre></div>
<p>其中 <code>extern char **environ</code> 这个变量是环境变量,大概率会在 <code>execve</code> 函数调用的时候被作为第三个参数传入;jobs则是任务列表</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">execve</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *envp[])</span>;
<span class="hljs-comment">// 如果成功不返回,如果错误返回-1</span></code></pre></div>
<p>execve函数加载并运行可执行目标文件filename,并且带参数列表argv和环境变量列表envp,与fork返回两次不同.execve调用一次并且不返回,只有出现错误,比如找到不到filename才会返回到调用程序</p>
<p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20221226211353.png" srcset="/img/loading.gif" lazyload alt="20221226211353" /></p>
<p>其中参数列表的数据结构如上图所示</p>
<p>argv变量指向一个null结尾的指针数组,每个指针指向一个参数字符串,通常来说argv[0]是可执行目标文件的名字</p>
<p>envp变量指向一个null结尾的指针数据,每个指针指向一个字符串,每个串都是类似&quot;name=value&quot;的键值对</p>
<hr />
<p>接下来是我们本次实验需要完成的一些函数,这里已经体现列了出来</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Here are the functions that you will implement */</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">eval</span><span class="hljs-params">(<span class="hljs-type">char</span> *cmdline)</span>;
<span class="hljs-type">int</span> <span class="hljs-title function_">builtin_cmd</span><span class="hljs-params">(<span class="hljs-type">char</span> **argv)</span>;
<span class="hljs-type">void</span> <span class="hljs-title function_">do_bgfg</span><span class="hljs-params">(<span class="hljs-type">char</span> **argv)</span>;
<span class="hljs-type">void</span> <span class="hljs-title function_">waitfg</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid)</span>;

<span class="hljs-type">void</span> <span class="hljs-title function_">sigchld_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span>;
<span class="hljs-type">void</span> <span class="hljs-title function_">sigtstp_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span>;
<span class="hljs-type">void</span> <span class="hljs-title function_">sigint_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span>;</code></pre></div>
<p>然后是一些本次实验中作者提供的一些辅助函数,我们需要在完成这几个函数的同时利用到作者提供的这些辅助函数来执行或者或许信息,具体的函数内容我们放到对应的出现位置再去讲解</p>
<p>接下来就是main函数了,先判断一下有没有携带<code>-h</code> <code>-v</code> <code>-p</code>参数,如果使用了那么执行相关函数.接下来使用<code>Signal</code>将四个中断信号注册到对应的方法.<code>initjob</code>将所有的任务初始化,进入while(1)死循环,输出prompt即<code>tsh&gt;</code>,刷新标准输出流然后进入<code>eval</code>,接着再次刷新,进入循环.</p>
<p>现在我们的eval函数暂时未完成,所以整个程序运行的流程大致如此.</p>
<p>你可以直接运行编译后的tsh进入shell然后一行一行输入对应内容</p>
<div class="code-wrapper"><pre><code class="hljs bash">./tsh

tsh&gt; ....</code></pre></div>
<hr />
<p>这里顺带提一句,编写的代码可能导致程序陷入死循环或者无法退出进程,这时候可以退出当前命令行,然后重新登录命令行</p>
<p>使用 <code>ps -ef | grep tsh</code>找到tsh进程的id(这里是14284)</p>
<div class="code-wrapper"><pre><code class="hljs bash">root@da1811a84ddc:~<span class="hljs-comment"># ps -ef | grep tsh</span>
root     14284 14274  0 14:43 pts/10   00:00:00 ./tsh
root     14296 14285  0 14:43 pts/12   00:00:00 grep --color=auto tsh</code></pre></div>
<p>然后使用 <code>kill -9 14284</code> 杀死这个进程即可</p>
<hr />
<p>除此之外我们注意到Makefile中提供了很方便的测试指令,比如想要测试trace08是否通过,可以使用</p>
<div class="code-wrapper"><pre><code class="hljs bash">make test08</code></pre></div>
<p>检测是否正确,可以使用</p>
<div class="code-wrapper"><pre><code class="hljs bash">make rtest08</code></pre></div>
<p>这里由于两次pid不同所以输出会有一点点差异,我们可以对比两次结果来判断是否正确实现了shell</p>
<h3 id="trace01"><a class="markdownIt-Anchor" href="#trace01"></a> trace01</h3>
<div class="code-wrapper"><pre><code class="hljs txt">#
# trace01.txt - Properly terminate on EOF.
#
CLOSE
WAIT</code></pre></div>
<p>第一关的输入是CLOSE和WAIT,这两个命令并没有什么作用,所以什么也不需要改动</p>
<h3 id="trace02"><a class="markdownIt-Anchor" href="#trace02"></a> trace02</h3>
<div class="code-wrapper"><pre><code class="hljs txt">#
# trace02.txt - Process builtin quit command.
#
quit
WAIT</code></pre></div>
<p>第二关需要我们实现内置命令&quot;quit&quot;,当输入quit之后退出当前shell.我们完善一下eval函数解析命令行</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">eval</span><span class="hljs-params">(<span class="hljs-type">char</span> *cmdline)</span> 
&#123;
    <span class="hljs-type">char</span> *argv[MAXARGS];
    <span class="hljs-type">char</span> buf[MAXLINE];
    <span class="hljs-type">int</span> bg;
    <span class="hljs-built_in">strcpy</span>(buf,cmdline);
    bg=parseline(buf,argv);
    <span class="hljs-keyword">if</span> (argv[<span class="hljs-number">0</span>] == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;
    builtin_cmd(argv);<span class="hljs-comment">//读取到quit就退出了</span>
    <span class="hljs-keyword">return</span>;
&#125;
<span class="hljs-type">int</span> <span class="hljs-title function_">builtin_cmd</span><span class="hljs-params">(<span class="hljs-type">char</span> **argv)</span> 
&#123;
    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>],<span class="hljs-string">&quot;quit&quot;</span>)) <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;     <span class="hljs-comment">/* not a builtin command */</span>
&#125;</code></pre></div>
<p>这里的parseline是一个解析命令行的函数,可以将传入的字符串通过空格拆分,并将拆分后的结果保存在argv中</p>
<p>它的返回值用于判断是否是一个后台进程,如果是返回1否则返回0</p>
<p>然后判断一下是否是空输入,是则直接返回</p>
<p>接下来实现builtin_cmd对于内置命令的解析,判断第一个参数是否是&quot;quit&quot;,如果是则直接退出</p>
<h3 id="trace03"><a class="markdownIt-Anchor" href="#trace03"></a> trace03</h3>
<div class="code-wrapper"><pre><code class="hljs txt">#
# trace03.txt - Run a foreground job.
#
/bin/echo tsh&gt; quit
quit</code></pre></div>
<p>第三关加入了一个新的测试命令,其中<code>/bin/echo</code>是Linux中一个文件,一个可执行程序.它的作用是输出后面的字符串.你可以直接在命令行中使用这个指令</p>
<div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> hello world</code></pre></div>
<blockquote>
<p>这里直接使用echo是因为默认会把/bin目录加入到环境变量之中,它与使用/bin/echo是完全等价的</p>
</blockquote>
<p>所以如果想要在我们的shell中执行/bin/echo,我们需要在解析完成之后创建一个子进程,然后交由操作系统去执行</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">eval</span><span class="hljs-params">(<span class="hljs-type">char</span> *cmdline)</span>
&#123;
    <span class="hljs-type">char</span> *argv[MAXARGS];
    <span class="hljs-type">char</span> buf[MAXLINE];
    <span class="hljs-type">int</span> bg;
    <span class="hljs-type">pid_t</span> pid;
    <span class="hljs-built_in">strcpy</span>(buf,cmdline);
    bg=parseline(buf,argv);
    <span class="hljs-keyword">if</span> (argv[<span class="hljs-number">0</span>] == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">if</span> (!builtin_cmd(argv)) &#123;
        <span class="hljs-keyword">if</span> ((pid = fork()) == <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">if</span> (execve(argv[<span class="hljs-number">0</span>],argv,environ) &lt; <span class="hljs-number">0</span>) &#123;
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: Command not found\n&quot;</span>,argv[<span class="hljs-number">0</span>]);
                <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span>;
&#125;</code></pre></div>
<p>先使用builtin_cmd判断是否是内置的指令,如果不是则fork一个子进程,使用execve函数去执行当前的参数.execve函数的三个参数分别是argv[0]即&quot;/bin/echo&quot;这个程序的名字,argv其余参数包括需要输出的字符串,environ环境变量信息,这个值直接使用整个shell中的环境变量信息</p>
<blockquote>
<p>注意这里有一点点小问题,如果运行make test03那么输出正常,但是如果进入tsh并且输入<code>/bin/echo tsh&gt; quit</code>你会发现出现了 <code>tsh&gt;</code>的前缀,<strong>这里是一个bug</strong>,因为我们现在还并没有去处理子进程,我们会在下一关中完善<code>sigchld_handler</code>来解决这个问题</p>
</blockquote>
<h3 id="trace04"><a class="markdownIt-Anchor" href="#trace04"></a> trace04</h3>
<div class="code-wrapper"><pre><code class="hljs txt">#
# trace04.txt - Run a background job.
#
/bin/echo -e tsh&gt; ./myspin 1 \046
./myspin 1 &amp;</code></pre></div>
<p>第四关首先是-e,这是echo的一个参数,用于激活转义字符,这里我们不需要考虑太多</p>
<p>然后是运行了一个程序myspin,参数是1,并且在后台执行.</p>
<blockquote>
<p>这里的myspin函数实现很简单,就是休眠n秒,n为传入的参数.这里是休眠1s</p>
</blockquote>
<p>这里我先放出修改后的代码,然后我们一点一点看</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">eval</span><span class="hljs-params">(<span class="hljs-type">char</span> *cmdline)</span> &#123;
  <span class="hljs-type">char</span> *argv[MAXARGS];
  <span class="hljs-type">char</span> buf[MAXLINE];
  <span class="hljs-type">int</span> bg;
  <span class="hljs-type">pid_t</span> pid;
  <span class="hljs-built_in">strcpy</span>(buf, cmdline);
  bg = parseline(buf, argv);
  <span class="hljs-keyword">if</span> (argv[<span class="hljs-number">0</span>] == <span class="hljs-literal">NULL</span>)
    <span class="hljs-keyword">return</span>;

  <span class="hljs-type">sigset_t</span> mask_all, mask_one, prev;
  sigfillset(&amp;mask_all);
  sigemptyset(&amp;mask_one);
  sigaddset(&amp;mask_one, SIGCHLD);
  <span class="hljs-keyword">if</span> (!builtin_cmd(argv)) &#123;
    sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;prev);
    <span class="hljs-keyword">if</span> ((pid = fork()) == <span class="hljs-number">0</span>) &#123;
      sigprocmask(SIG_SETMASK, &amp;prev, <span class="hljs-literal">NULL</span>);
      setpgid(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
      <span class="hljs-keyword">if</span> (execve(argv[<span class="hljs-number">0</span>], argv, environ) &lt; <span class="hljs-number">0</span>) &#123;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: Command not found\n&quot;</span>, argv[<span class="hljs-number">0</span>]);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
      &#125;
    &#125;
    <span class="hljs-keyword">if</span> (!bg) &#123;
      <span class="hljs-comment">// 对于前台进程，添加job后解除阻塞，并通过waitfg等待子进程结束后回收</span>
      sigprocmask(SIG_BLOCK, &amp;mask_all, <span class="hljs-literal">NULL</span>);
      addjob(jobs, pid, FG, cmdline);
      sigprocmask(SIG_SETMASK, &amp;prev, <span class="hljs-literal">NULL</span>);
      waitfg(pid);
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-comment">// 后台进程不需要等待子进程，进程结束之后收到SIGCHLD信号回收即可</span>
      sigprocmask(SIG_BLOCK, &amp;mask_all, <span class="hljs-literal">NULL</span>);
      addjob(jobs, pid, BG, cmdline);
      sigprocmask(SIG_SETMASK, &amp;prev, <span class="hljs-literal">NULL</span>);
      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(pid), pid, cmdline);
    &#125;
  &#125;

  <span class="hljs-keyword">return</span>;
&#125;
<span class="hljs-type">void</span> <span class="hljs-title function_">waitfg</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid)</span> &#123;
  <span class="hljs-type">sigset_t</span> mask;
  sigemptyset(&amp;mask);
  <span class="hljs-keyword">while</span> (pid == fgpid(jobs))
    sigsuspend(&amp;mask);
  <span class="hljs-keyword">return</span>;
&#125;
<span class="hljs-type">void</span> <span class="hljs-title function_">sigchld_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span> &#123;
  <span class="hljs-type">pid_t</span> pid;
  <span class="hljs-type">int</span> status;
  <span class="hljs-type">sigset_t</span> mask_all, prev;
  sigfillset(&amp;mask_all);
  <span class="hljs-keyword">while</span> ((pid = waitpid(<span class="hljs-number">-1</span>, &amp;status, WNOHANG | WUNTRACED)) &gt; <span class="hljs-number">0</span>) &#123;
    <span class="hljs-keyword">if</span> (WIFEXITED(status)) <span class="hljs-comment">// 正常退出 delete</span>
    &#123;
      sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev);
      deletejob(jobs, pid);
      sigprocmask(SIG_SETMASK, &amp;prev, <span class="hljs-literal">NULL</span>);
    &#125;
  &#125;
  <span class="hljs-keyword">return</span>;
&#125;</code></pre></div>
<blockquote>
<p>如果你对这部分代码感到疑惑,请重新阅读第八章</p>
</blockquote>
<p>首先是加入了信号和阻塞,在fork之前阻塞SIGCHLD信号,以防子进程和父进程竞争.判断该进程是前台进程还是后台进程之后使用addjob添加对应的job类型,然后解除阻塞,再去响应子进程结束信号SIGCHLD,确保addjob操作deletejob操作顺序对应</p>
<p>如果是前台进程比如echo,那么使用waitfg等待前台进程结束,waitfg的具体实现就是调用fgpid找到当前的前台进程,然后判断处于前台的进程pid是否是该pid,即前台进程仍然没有执行结束,那么挂起当前进程sigsuspend等待结束</p>
<p>如果后台进程比如myspin,那么使用addjob加入任务队列之后就不需要关心了,使用printf输出一句话即可(与make rtest04的结果相同)</p>
<blockquote>
<p>这里使用了开头定义的宏BG FG</p>
</blockquote>
<p>对于子进程结束的信号SIGCHLD的处理则完成对应的sigchld_handler,这里的waitpid使用的第三个参数位置是<code>WNOHANG | WUNTRACED</code>代表立即返回,然后判断一下返回的状态,如果是正常退出那么deletejob删除对应任务即可</p>
<p>除此之外还需要注意在创建子进程之后使用了<code>setpgid(0, 0)</code>,这里的作用是将子进程的gpid组设置与父进程pid相同</p>
<p>运行<code>make test04</code>后结果如下,其中pid可能不同,导致pid2jid的结果不同</p>
<blockquote>
<p>这里简单解释一下,2同英文to,所以日常编程之中经常使用2来代指to表示转换,这里的pid2jid类似pid_to_jid</p>
</blockquote>
<div class="code-wrapper"><pre><code class="hljs bash">./sdriver.pl -t trace04.txt -s ./tsh -a <span class="hljs-string">&quot;-p&quot;</span>
<span class="hljs-comment">#</span>
<span class="hljs-comment"># trace04.txt - Run a background job.</span>
<span class="hljs-comment">#</span>
tsh&gt; ./myspin 1 &amp;
[1] (980) ./myspin 1 &amp;</code></pre></div>
<h3 id="trace05"><a class="markdownIt-Anchor" href="#trace05"></a> trace05</h3>
<div class="code-wrapper"><pre><code class="hljs txt">#
# trace05.txt - Process jobs builtin command.
#
/bin/echo -e tsh&gt; ./myspin 2 \046
./myspin 2 &amp;

/bin/echo -e tsh&gt; ./myspin 3 \046
./myspin 3 &amp;

/bin/echo tsh&gt; jobs
jobs</code></pre></div>
<p>第五关是分别运行了前台echo,后台myspin,前台echo,后台myspin,前台echo,前台jobs</p>
<p>这里需要实现一个内置命令jobs,功能是显示目前任务列表中的所有任务以及所有属性,这里可以利用listjob函数</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">builtin_cmd</span><span class="hljs-params">(<span class="hljs-type">char</span> **argv)</span> &#123;
  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;quit&quot;</span>)) &#123;
	  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
  &#125;
  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>],<span class="hljs-string">&quot;jobs&quot;</span>)) &#123;
      listjobs(jobs);
      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  &#125;
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* not a builtin command */</span>
&#125;</code></pre></div>
<h3 id="trace06"><a class="markdownIt-Anchor" href="#trace06"></a> trace06</h3>
<div class="code-wrapper"><pre><code class="hljs txt">#
# trace06.txt - Forward SIGINT to foreground job.
#
/bin/echo -e tsh&gt; ./myspin 4
./myspin 4

SLEEP 2
INT</code></pre></div>
<p>第六关加入了INT,表示接收到了中断信号SIGINT(即CTRL_C),那么结束前台进程,此时需要我们完成sigint_handler</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">sigchld_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span> &#123;
  <span class="hljs-type">pid_t</span> pid;
  <span class="hljs-type">int</span> status;
  <span class="hljs-type">sigset_t</span> mask_all, prev;
  sigfillset(&amp;mask_all);
  <span class="hljs-keyword">while</span> ((pid = waitpid(<span class="hljs-number">-1</span>, &amp;status, WNOHANG | WUNTRACED)) &gt; <span class="hljs-number">0</span>) &#123;
    <span class="hljs-keyword">if</span> (WIFEXITED(status)) <span class="hljs-comment">// 正常退出 delete</span>
    &#123;
      sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev);
      deletejob(jobs, pid);
      sigprocmask(SIG_SETMASK, &amp;prev, <span class="hljs-literal">NULL</span>);
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (WIFSIGNALED(status)) <span class="hljs-comment">// 信号退出 delete</span>
    &#123;
      sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev);
      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Job [%d] (%d) terminated by signal %d\n&quot;</span>, pid2jid(pid), pid, WTERMSIG(status));
	  deletejob(jobs, pid);
      sigprocmask(SIG_SETMASK, &amp;prev, <span class="hljs-literal">NULL</span>);
    &#125;
  &#125;
  <span class="hljs-keyword">return</span>;
&#125;

<span class="hljs-type">void</span> <span class="hljs-title function_">sigint_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span> &#123;
	<span class="hljs-type">sigset_t</span> mask_all, prev;
	sigfillset(&amp;mask_all);
	sigprocmask(SIG_SETMASK, &amp;mask_all, &amp;prev);
	<span class="hljs-type">pid_t</span> pid = fgpid(jobs);
	<span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>) &#123;
		kill(-pid,sig);
	&#125;
  sigprocmask(SIG_SETMASK, &amp;prev, <span class="hljs-literal">NULL</span>);
	<span class="hljs-keyword">return</span>;
&#125;</code></pre></div>
<p>这里修改了两个地方,首先是完成了sigint_handler,如果接收到了INT信号,则通过fgpid找到当前的前台进程,使用kill杀死这个进程.这里kill的第一个参数是负数,代表杀死这个进程组的所有进程,对子进程及其所有后代都发送终止信号</p>
<p>另外值得一提的是对于INT终止类型我们将printf的输出内容写在sigchld_handler中而不是sigint_handler,实际上如果你写在sigint_handler中对于这道题来说也是可以的,但是意义完全不同</p>
<ul>
<li>如果写在sigint_handler,那么代表每次处理INT中断的时候输出这句话,与子进程无关</li>
<li>如果写在sigchld_handler,那么代表是子进程结束了,并且捕捉到是来自WIFSIGNALED的信号退出方式,对应INT,所以输出这句话</li>
</ul>
<p>后者的写法才是正确的,前者的写法会导致来自外界的中断信号无法别识别,你会在trace16中看到差距</p>
<p>此外应该注意对于WIFSIGNALED的处理中应该先printf后delete,其实顺序无所谓,只是为了和tshref的输出相同</p>
<h3 id="trace07"><a class="markdownIt-Anchor" href="#trace07"></a> trace07</h3>
<p>第七关没有任何新的命令,检测你之前是否是正确完成了所有的函数,有没有投机取巧</p>
<p>如果你之前都正确完成了,那么不需要改动直接通过</p>
<h3 id="trace08"><a class="markdownIt-Anchor" href="#trace08"></a> trace08</h3>
<div class="code-wrapper"><pre><code class="hljs txt">#
# trace08.txt - Forward SIGTSTP only to foreground job.
#
/bin/echo -e tsh&gt; ./myspin 4 \046
./myspin 4 &amp;

/bin/echo -e tsh&gt; ./myspin 5
./myspin 5

SLEEP 2
TSTP

/bin/echo tsh&gt; jobs
jobs</code></pre></div>
<p>第八关加入了TSTP(CTRL_Z),当接收到了TSTP中断信号（即CTRL_Z),将前台进程挂起,然后输出被挂起的任务,和INT类似,完成两个函数</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">sigchld_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span> &#123;
  <span class="hljs-type">pid_t</span> pid;
  <span class="hljs-type">int</span> status;
  <span class="hljs-type">sigset_t</span> mask_all, prev;
  sigfillset(&amp;mask_all);
  <span class="hljs-keyword">while</span> ((pid = waitpid(<span class="hljs-number">-1</span>, &amp;status, WNOHANG | WUNTRACED)) &gt; <span class="hljs-number">0</span>) &#123;
    <span class="hljs-keyword">if</span> (WIFEXITED(status)) <span class="hljs-comment">// 正常退出 delete</span>
    &#123;
      sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev);
      deletejob(jobs, pid);
      sigprocmask(SIG_SETMASK, &amp;prev, <span class="hljs-literal">NULL</span>);
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (WIFSIGNALED(status)) <span class="hljs-comment">// 信号退出 delete</span>
    &#123;
      sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev);
      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Job [%d] (%d) terminated by signal %d\n&quot;</span>, pid2jid(pid), pid, WTERMSIG(status));
      deletejob(jobs, pid);
      sigprocmask(SIG_SETMASK, &amp;prev, <span class="hljs-literal">NULL</span>);
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (WIFSTOPPED(status)) &#123;
      sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev);
      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">job_t</span> *<span class="hljs-title">job</span>=</span>getjobpid(jobs,pid);
      job-&gt;state=ST;
      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Job [%d] (%d) stopped by signal %d\n&quot;</span>,pid2jid(pid),pid,WSTOPSIG(status));
      sigprocmask(SIG_SETMASK, &amp;prev, <span class="hljs-literal">NULL</span>);
    &#125;
  &#125;
  <span class="hljs-keyword">return</span>;
&#125;

<span class="hljs-type">void</span> <span class="hljs-title function_">sigtstp_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span> &#123;
	<span class="hljs-type">sigset_t</span> mask_all, prev;
	sigfillset(&amp;mask_all);
	sigprocmask(SIG_SETMASK, &amp;mask_all, &amp;prev);
	<span class="hljs-type">pid_t</span> pid = fgpid(jobs);
	<span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>) &#123;
		kill(-pid,sig);
	&#125;
    sigprocmask(SIG_SETMASK, &amp;prev, <span class="hljs-literal">NULL</span>);
	<span class="hljs-keyword">return</span>;
&#125;</code></pre></div>
<p>其中sigtstp_handler与sigint_handler实现完全相同,在sigchld_handler中找到对于TSTP(WIFSTOPPED)的信号,通过getjobpid找到对应任务并将其state修改为ST即可</p>
<h3 id="trace09"><a class="markdownIt-Anchor" href="#trace09"></a> trace09</h3>
<div class="code-wrapper"><pre><code class="hljs txt">#
# trace09.txt - Process bg builtin command
#
/bin/echo -e tsh&gt; ./myspin 4 \046
./myspin 4 &amp;

/bin/echo -e tsh&gt; ./myspin 5
./myspin 5

SLEEP 2
TSTP

/bin/echo tsh&gt; jobs
jobs

/bin/echo tsh&gt; bg %2
bg %2

/bin/echo tsh&gt; jobs
jobs</code></pre></div>
<p>其中加入了bg命令,我们可以在开头的注释中找到对应命令所表示的含义</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span>
<span class="hljs-comment"> * Jobs states: FG (foreground), BG (background), ST (stopped)</span>
<span class="hljs-comment"> * Job state transitions and enabling actions:</span>
<span class="hljs-comment"> *     FG -&gt; ST  : ctrl-z</span>
<span class="hljs-comment"> *     ST -&gt; FG  : fg command</span>
<span class="hljs-comment"> *     ST -&gt; BG  : bg command</span>
<span class="hljs-comment"> *     BG -&gt; FG  : fg command</span>
<span class="hljs-comment"> * At most 1 job can be in the FG state.</span>
<span class="hljs-comment"> */</span></code></pre></div>
<p>其中bg command代表将一个ST进程变为BG进程,即将挂起的进程调入后台执行,我们需要完成builtin_cmd和do_bgfg函数</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">builtin_cmd</span><span class="hljs-params">(<span class="hljs-type">char</span> **argv)</span> &#123;
  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;quit&quot;</span>)) &#123;
	<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
  &#125;
  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>],<span class="hljs-string">&quot;jobs&quot;</span>)) &#123;
	listjobs(jobs);
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  &#125;
  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;bg&quot;</span>)) &#123;
	do_bgfg(argv);
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  &#125;
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* not a builtin command */</span>
&#125;
<span class="hljs-type">void</span> <span class="hljs-title function_">do_bgfg</span><span class="hljs-params">(<span class="hljs-type">char</span> **argv)</span> &#123;

	<span class="hljs-type">int</span> jid;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">job_t</span> *<span class="hljs-title">job</span>;</span>
	<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;bg&quot;</span>)) &#123;
		jid = atoi(&amp;argv[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);
		job=getjobjid(jobs,jid);
        job-&gt;state=BG;
        kill(-(job-&gt;pid),SIGCONT);
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d] (%d) %s&quot;</span>, jid, job-&gt;pid, job-&gt;cmdline);
	&#125;
	<span class="hljs-keyword">return</span>;
&#125;</code></pre></div>
<p>这里使用了atoi的C库函数,将字符串转为int类型,因为bg的命令的输入格式是 % + jid, 所以使用argv[1][1]获取该jid的字符串的起始地址</p>
<p>通过getjobjid找到对应的job后修改state为BG,同时发送SIGCONT信号使其执行.单纯修改state毫无意义,必须发送信号使其真正由挂起状态转入运行状态</p>
<h3 id="trace10"><a class="markdownIt-Anchor" href="#trace10"></a> trace10</h3>
<p>第十关类似,只不过是fg命令</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span>
<span class="hljs-comment"> * Jobs states: FG (foreground), BG (background), ST (stopped)</span>
<span class="hljs-comment"> * Job state transitions and enabling actions:</span>
<span class="hljs-comment"> *     FG -&gt; ST  : ctrl-z</span>
<span class="hljs-comment"> *     ST -&gt; FG  : fg command</span>
<span class="hljs-comment"> *     ST -&gt; BG  : bg command</span>
<span class="hljs-comment"> *     BG -&gt; FG  : fg command</span>
<span class="hljs-comment"> * At most 1 job can be in the FG state.</span>
<span class="hljs-comment"> */</span></code></pre></div>
<p>可以看到fg命令有两种情况,分别是将一个挂起进程调入前台,和将一个后台进程调入前台</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">builtin_cmd</span><span class="hljs-params">(<span class="hljs-type">char</span> **argv)</span> &#123;
  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;quit&quot;</span>)) &#123;
	<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
  &#125;
  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>],<span class="hljs-string">&quot;jobs&quot;</span>)) &#123;
	listjobs(jobs);
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  &#125;
  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;bg&quot;</span>) || !<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>],<span class="hljs-string">&quot;fg&quot;</span>)) &#123;
	do_bgfg(argv);
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  &#125;
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* not a builtin command */</span>
&#125;

<span class="hljs-type">void</span> <span class="hljs-title function_">do_bgfg</span><span class="hljs-params">(<span class="hljs-type">char</span> **argv)</span> &#123;

	<span class="hljs-type">int</span> jid;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">job_t</span> *<span class="hljs-title">job</span>;</span>
	<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;bg&quot;</span>)) &#123;
		jid = atoi(&amp;argv[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);
		job=getjobjid(jobs,jid);
        job-&gt;state=BG;
        kill(-(job-&gt;pid),SIGCONT);
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d] (%d) %s&quot;</span>, jid, job-&gt;pid, job-&gt;cmdline);
	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;fg&quot;</span>)) &#123;
		jid=atoi(&amp;argv[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);
        job=getjobjid(jobs,jid);
		<span class="hljs-keyword">if</span> (job-&gt;state == ST) &#123;
			<span class="hljs-comment">//如果是挂起程序就重启并且转到前台，等待结束</span>
			job-&gt;state=FG;
            kill(-(job-&gt;pid),SIGCONT);
            waitfg(job-&gt;pid);
		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (job-&gt;state == BG) &#123;
			<span class="hljs-comment">//如果是后台程序就转到前台并等待结束</span>
			job-&gt;state=FG;
            waitfg(job-&gt;pid);
		&#125;
	&#125;
	<span class="hljs-keyword">return</span>;
&#125;
</code></pre></div>
<p>前台程序和后台程序主要差异就是shell会不会等待你结束,前台shell主动等待waitfg,然后回收掉,后台就是什么时候结束什么时候返回SIGCHILD,然后回收掉</p>
<h3 id="trace11"><a class="markdownIt-Anchor" href="#trace11"></a> trace11</h3>
<p>不需要修改</p>
<h3 id="trace12"><a class="markdownIt-Anchor" href="#trace12"></a> trace12</h3>
<p>不需要修改</p>
<h3 id="trace13"><a class="markdownIt-Anchor" href="#trace13"></a> trace13</h3>
<p>不需要修改</p>
<h3 id="trace14"><a class="markdownIt-Anchor" href="#trace14"></a> trace14</h3>
<p>本关主要是测试所有的命令，判断是否正确。这一关没有技术难关，主要就是对照输出结果完善你的shell对于错误的处理</p>
<p>注意大小写！ 注意标点！ 注意空格！</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">eval</span><span class="hljs-params">(<span class="hljs-type">char</span> **cmdline)</span> &#123;
    ...
    <span class="hljs-keyword">if</span> (execve(argv[<span class="hljs-number">0</span>], argv, environ) &lt; <span class="hljs-number">0</span>) &#123;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: Command not found\n&quot;</span>, argv[<span class="hljs-number">0</span>]);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
      &#125;
&#125;

<span class="hljs-type">void</span> <span class="hljs-title function_">do_bgfg</span><span class="hljs-params">(<span class="hljs-type">char</span> **argv)</span> &#123;

	<span class="hljs-type">int</span> jid;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">job_t</span> *<span class="hljs-title">job</span>;</span>
	<span class="hljs-keyword">if</span>(argv[<span class="hljs-number">1</span>]==<span class="hljs-literal">NULL</span>)&#123;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>,argv[<span class="hljs-number">0</span>]);
        <span class="hljs-keyword">return</span> ;
    &#125;
	<span class="hljs-keyword">if</span>(argv[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;%&#x27;</span>)&#123;
        jid=atoi(&amp;argv[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);
        job=getjobjid(jobs,jid);
        <span class="hljs-keyword">if</span>(job==<span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%%%d: No such job\n&quot;</span>,jid);
            <span class="hljs-keyword">return</span> ;
        &#125;
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isdigit</span>(argv[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]))&#123;
        jid = atoi(argv[<span class="hljs-number">1</span>]);        
        job=getjobjid(jobs,jid);
        <span class="hljs-keyword">if</span>(job==<span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%d): No such process\n&quot;</span>,jid);
            <span class="hljs-keyword">return</span> ;
        &#125;

    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>,argv[<span class="hljs-number">0</span>]);
        <span class="hljs-keyword">return</span> ;
    &#125;
	<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;bg&quot;</span>)) &#123;
        job-&gt;state=BG;
        kill(-(job-&gt;pid),SIGCONT);
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d] (%d) %s&quot;</span>, jid, job-&gt;pid, job-&gt;cmdline);
	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;fg&quot;</span>)) &#123;
		<span class="hljs-keyword">if</span> (job-&gt;state == ST) &#123;
			<span class="hljs-comment">//如果是挂起程序就重启并且转到前台，等待结束</span>
			job-&gt;state=FG;
            kill(-(job-&gt;pid),SIGCONT);
            waitfg(job-&gt;pid);
		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (job-&gt;state == BG) &#123;
			<span class="hljs-comment">//如果是后台程序就转到前台并等待结束</span>
			job-&gt;state=FG;
            waitfg(job-&gt;pid);
		&#125;
	&#125;
	<span class="hljs-keyword">return</span>;
&#125;</code></pre></div>
<h3 id="trace15"><a class="markdownIt-Anchor" href="#trace15"></a> trace15</h3>
<p>还是大小写和标点空格</p>
<h3 id="trace16"><a class="markdownIt-Anchor" href="#trace16"></a> trace16</h3>
<p>这里使用了myint,对于INT handler的处理需要注意,这一点我们在前文trace06已经提及过了,这里不再赘述</p>
<p>下附完整代码</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span>
<span class="hljs-comment"> * tsh - A tiny shell program with job control</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * lzx 2019300003075</span>
<span class="hljs-comment"> */</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span>

<span class="hljs-comment">/* Misc manifest constants */</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXLINE 1024   <span class="hljs-comment">/* max line size */</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXARGS 128    <span class="hljs-comment">/* max args on a command line */</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXJOBS 16     <span class="hljs-comment">/* max jobs at any point in time */</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXJID 1 &lt;&lt; 16 <span class="hljs-comment">/* max job ID */</span></span>

<span class="hljs-comment">/* Job states */</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> UNDEF 0 <span class="hljs-comment">/* undefined */</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> FG 1    <span class="hljs-comment">/* running in foreground */</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> BG 2    <span class="hljs-comment">/* running in background */</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ST 3    <span class="hljs-comment">/* stopped */</span></span>

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * Jobs states: FG (foreground), BG (background), ST (stopped)</span>
<span class="hljs-comment"> * Job state transitions and enabling actions:</span>
<span class="hljs-comment"> *     FG -&gt; ST  : ctrl-z</span>
<span class="hljs-comment"> *     ST -&gt; FG  : fg command</span>
<span class="hljs-comment"> *     ST -&gt; BG  : bg command</span>
<span class="hljs-comment"> *     BG -&gt; FG  : fg command</span>
<span class="hljs-comment"> * At most 1 job can be in the FG state.</span>
<span class="hljs-comment"> */</span>

<span class="hljs-comment">/* Global variables */</span>
<span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> **environ;   <span class="hljs-comment">/* defined in libc */</span>
<span class="hljs-type">char</span> prompt[] = <span class="hljs-string">&quot;tsh&gt; &quot;</span>; <span class="hljs-comment">/* command line prompt (DO NOT CHANGE) */</span>
<span class="hljs-type">int</span> verbose = <span class="hljs-number">0</span>;         <span class="hljs-comment">/* if true, print additional output */</span>
<span class="hljs-type">int</span> nextjid = <span class="hljs-number">1</span>;         <span class="hljs-comment">/* next job ID to allocate */</span>
<span class="hljs-type">char</span> sbuf[MAXLINE];      <span class="hljs-comment">/* for composing sprintf messages */</span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">job_t</span> &#123;</span>           <span class="hljs-comment">/* The job struct */</span>
  <span class="hljs-type">pid_t</span> pid;             <span class="hljs-comment">/* job PID */</span>
  <span class="hljs-type">int</span> jid;               <span class="hljs-comment">/* job ID [1, 2, ...] */</span>
  <span class="hljs-type">int</span> state;             <span class="hljs-comment">/* UNDEF, BG, FG, or ST */</span>
  <span class="hljs-type">char</span> cmdline[MAXLINE]; <span class="hljs-comment">/* command line */</span>
&#125;;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">job_t</span> <span class="hljs-title">jobs</span>[<span class="hljs-title">MAXJOBS</span>];</span> <span class="hljs-comment">/* The job list */</span>
<span class="hljs-comment">/* End global variables */</span>

<span class="hljs-comment">/* Function prototypes */</span>

<span class="hljs-comment">/* Here are the functions that you will implement */</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">eval</span><span class="hljs-params">(<span class="hljs-type">char</span> *cmdline)</span>;
<span class="hljs-type">int</span> <span class="hljs-title function_">builtin_cmd</span><span class="hljs-params">(<span class="hljs-type">char</span> **argv)</span>;
<span class="hljs-type">void</span> <span class="hljs-title function_">do_bgfg</span><span class="hljs-params">(<span class="hljs-type">char</span> **argv)</span>;
<span class="hljs-type">void</span> <span class="hljs-title function_">waitfg</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid)</span>;

<span class="hljs-type">void</span> <span class="hljs-title function_">sigchld_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span>;
<span class="hljs-type">void</span> <span class="hljs-title function_">sigtstp_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span>;
<span class="hljs-type">void</span> <span class="hljs-title function_">sigint_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span>;

<span class="hljs-comment">/* Here are helper routines that we&#x27;ve provided for you */</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">parseline</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *cmdline, <span class="hljs-type">char</span> **argv)</span>;
<span class="hljs-type">void</span> <span class="hljs-title function_">sigquit_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span>;

<span class="hljs-type">void</span> <span class="hljs-title function_">clearjob</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">job_t</span> *job)</span>;
<span class="hljs-type">void</span> <span class="hljs-title function_">initjobs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">job_t</span> *jobs)</span>;
<span class="hljs-type">int</span> <span class="hljs-title function_">maxjid</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">job_t</span> *jobs)</span>;
<span class="hljs-type">int</span> <span class="hljs-title function_">addjob</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">job_t</span> *jobs, <span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> state, <span class="hljs-type">char</span> *cmdline)</span>;
<span class="hljs-type">int</span> <span class="hljs-title function_">deletejob</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">job_t</span> *jobs, <span class="hljs-type">pid_t</span> pid)</span>;
<span class="hljs-type">pid_t</span> <span class="hljs-title function_">fgpid</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">job_t</span> *jobs)</span>;
<span class="hljs-keyword">struct</span> <span class="hljs-type">job_t</span> *<span class="hljs-title function_">getjobpid</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">job_t</span> *jobs, <span class="hljs-type">pid_t</span> pid)</span>;
<span class="hljs-keyword">struct</span> <span class="hljs-type">job_t</span> *<span class="hljs-title function_">getjobjid</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">job_t</span> *jobs, <span class="hljs-type">int</span> jid)</span>;
<span class="hljs-type">int</span> <span class="hljs-title function_">pid2jid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid)</span>;
<span class="hljs-type">void</span> <span class="hljs-title function_">listjobs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">job_t</span> *jobs)</span>;

<span class="hljs-type">void</span> <span class="hljs-title function_">usage</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;
<span class="hljs-type">void</span> <span class="hljs-title function_">unix_error</span><span class="hljs-params">(<span class="hljs-type">char</span> *msg)</span>;
<span class="hljs-type">void</span> <span class="hljs-title function_">app_error</span><span class="hljs-params">(<span class="hljs-type">char</span> *msg)</span>;
<span class="hljs-keyword">typedef</span> <span class="hljs-type">void</span> <span class="hljs-title function_">handler_t</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;
<span class="hljs-type">handler_t</span> *<span class="hljs-title function_">Signal</span><span class="hljs-params">(<span class="hljs-type">int</span> signum, <span class="hljs-type">handler_t</span> *handler)</span>;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * main - The shell&#x27;s main routine</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> &#123;
  <span class="hljs-type">char</span> c;
  <span class="hljs-type">char</span> cmdline[MAXLINE];
  <span class="hljs-type">int</span> emit_prompt = <span class="hljs-number">1</span>; <span class="hljs-comment">/* emit prompt (default) */</span>

  <span class="hljs-comment">/* Redirect stderr to stdout (so that driver will get all output</span>
<span class="hljs-comment">   * on the pipe connected to stdout) */</span>
  dup2(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);

  <span class="hljs-comment">/* Parse the command line */</span>
  <span class="hljs-keyword">while</span> ((c = getopt(argc, argv, <span class="hljs-string">&quot;hvp&quot;</span>)) != EOF) &#123;
    <span class="hljs-keyword">switch</span> (c) &#123;
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;h&#x27;</span>: <span class="hljs-comment">/* print help message */</span>
      usage();
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;v&#x27;</span>: <span class="hljs-comment">/* emit additional diagnostic info */</span>
      verbose = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;p&#x27;</span>:          <span class="hljs-comment">/* don&#x27;t print a prompt */</span>
      emit_prompt = <span class="hljs-number">0</span>; <span class="hljs-comment">/* handy for automatic testing */</span>
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      usage();
    &#125;
  &#125;

  <span class="hljs-comment">/* Install the signal handlers */</span>

  <span class="hljs-comment">/* These are the ones you will need to implement */</span>
  Signal(SIGINT, sigint_handler);   <span class="hljs-comment">/* ctrl-c */</span>
  Signal(SIGTSTP, sigtstp_handler); <span class="hljs-comment">/* ctrl-z */</span>
  Signal(SIGCHLD, sigchld_handler); <span class="hljs-comment">/* Terminated or stopped child */</span>

  <span class="hljs-comment">/* This one provides a clean way to kill the shell */</span>
  Signal(SIGQUIT, sigquit_handler);

  <span class="hljs-comment">/* Initialize the job list */</span>
  initjobs(jobs);

  <span class="hljs-comment">/* Execute the shell&#x27;s read/eval loop */</span>
  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;

    <span class="hljs-comment">/* Read command line */</span>
    <span class="hljs-keyword">if</span> (emit_prompt) &#123;
      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, prompt);
      fflush(<span class="hljs-built_in">stdout</span>);
    &#125;
    <span class="hljs-keyword">if</span> ((fgets(cmdline, MAXLINE, <span class="hljs-built_in">stdin</span>) == <span class="hljs-literal">NULL</span>) &amp;&amp; ferror(<span class="hljs-built_in">stdin</span>))
      app_error(<span class="hljs-string">&quot;fgets error&quot;</span>);
    <span class="hljs-keyword">if</span> (feof(<span class="hljs-built_in">stdin</span>)) &#123; <span class="hljs-comment">/* End of file (ctrl-d) */</span>
      fflush(<span class="hljs-built_in">stdout</span>);
      <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
    &#125;

    <span class="hljs-comment">/* Evaluate the command line */</span>
    eval(cmdline);
    fflush(<span class="hljs-built_in">stdout</span>);
    fflush(<span class="hljs-built_in">stdout</span>);
  &#125;

  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">/* control never reaches here */</span>
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * eval - Evaluate the command line that the user has just typed in</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * If the user has requested a built-in command (quit, jobs, bg or fg)</span>
<span class="hljs-comment"> * then execute it immediately. Otherwise, fork a child process and</span>
<span class="hljs-comment"> * run the job in the context of the child. If the job is running in</span>
<span class="hljs-comment"> * the foreground, wait for it to terminate and then return.  Note:</span>
<span class="hljs-comment"> * each child process must have a unique process group ID so that our</span>
<span class="hljs-comment"> * background children don&#x27;t receive SIGINT (SIGTSTP) from the kernel</span>
<span class="hljs-comment"> * when we type ctrl-c (ctrl-z) at the keyboard.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">eval</span><span class="hljs-params">(<span class="hljs-type">char</span> *cmdline)</span> &#123;
  <span class="hljs-type">char</span> *argv[MAXARGS];
  <span class="hljs-type">char</span> buf[MAXLINE];
  <span class="hljs-type">int</span> bg;
  <span class="hljs-type">pid_t</span> pid;
  <span class="hljs-built_in">strcpy</span>(buf, cmdline);
  bg = parseline(buf, argv);
  <span class="hljs-keyword">if</span> (argv[<span class="hljs-number">0</span>] == <span class="hljs-literal">NULL</span>)
    <span class="hljs-keyword">return</span>;

  <span class="hljs-type">sigset_t</span> mask_all, mask_one, prev;
  sigfillset(&amp;mask_all);
  sigemptyset(&amp;mask_one);
  sigaddset(&amp;mask_one, SIGCHLD);
  <span class="hljs-keyword">if</span> (!builtin_cmd(argv)) &#123;
    sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;prev);
    <span class="hljs-keyword">if</span> ((pid = fork()) == <span class="hljs-number">0</span>) &#123;
      sigprocmask(SIG_SETMASK, &amp;prev, <span class="hljs-literal">NULL</span>);
      setpgid(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
      <span class="hljs-keyword">if</span> (execve(argv[<span class="hljs-number">0</span>], argv, environ) &lt; <span class="hljs-number">0</span>) &#123;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: Command not found\n&quot;</span>, argv[<span class="hljs-number">0</span>]);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
      &#125;
    &#125;
    <span class="hljs-keyword">if</span> (!bg) &#123;
      <span class="hljs-comment">// 对于前台进程，添加job后解除阻塞，并通过waitfg等待子进程结束后回收</span>
      sigprocmask(SIG_BLOCK, &amp;mask_all, <span class="hljs-literal">NULL</span>);
      addjob(jobs, pid, FG, cmdline);
      sigprocmask(SIG_SETMASK, &amp;prev, <span class="hljs-literal">NULL</span>);
      waitfg(pid);
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-comment">// 后台进程不需要等待子进程，进程结束之后收到SIGCHLD信号回收即可</span>
      sigprocmask(SIG_BLOCK, &amp;mask_all, <span class="hljs-literal">NULL</span>);
      addjob(jobs, pid, BG, cmdline);
      sigprocmask(SIG_SETMASK, &amp;prev, <span class="hljs-literal">NULL</span>);
      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(pid), pid, cmdline);
    &#125;
  &#125;

  <span class="hljs-keyword">return</span>;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * parseline - Parse the command line and build the argv array.</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * Characters enclosed in single quotes are treated as a single</span>
<span class="hljs-comment"> * argument.  Return true if the user has requested a BG job, false if</span>
<span class="hljs-comment"> * the user has requested a FG job.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">parseline</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *cmdline, <span class="hljs-type">char</span> **argv)</span> &#123;
  <span class="hljs-type">static</span> <span class="hljs-type">char</span> <span class="hljs-built_in">array</span>[MAXLINE]; <span class="hljs-comment">/* holds local copy of command line */</span>
  <span class="hljs-type">char</span> *buf = <span class="hljs-built_in">array</span>;          <span class="hljs-comment">/* ptr that traverses command line */</span>
  <span class="hljs-type">char</span> *delim;                <span class="hljs-comment">/* points to first space delimiter */</span>
  <span class="hljs-type">int</span> argc;                   <span class="hljs-comment">/* number of args */</span>
  <span class="hljs-type">int</span> bg;                     <span class="hljs-comment">/* background job? */</span>

  <span class="hljs-built_in">strcpy</span>(buf, cmdline);
  buf[<span class="hljs-built_in">strlen</span>(buf) - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27; &#x27;</span>;   <span class="hljs-comment">/* replace trailing &#x27;\n&#x27; with space */</span>
  <span class="hljs-keyword">while</span> (*buf &amp;&amp; (*buf == <span class="hljs-string">&#x27; &#x27;</span>)) <span class="hljs-comment">/* ignore leading spaces */</span>
    buf++;

  <span class="hljs-comment">/* Build the argv list */</span>
  argc = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">if</span> (*buf == <span class="hljs-string">&#x27;\&#x27;&#x27;</span>) &#123;
    buf++;
    delim = <span class="hljs-built_in">strchr</span>(buf, <span class="hljs-string">&#x27;\&#x27;&#x27;</span>);
  &#125; <span class="hljs-keyword">else</span> &#123;
    delim = <span class="hljs-built_in">strchr</span>(buf, <span class="hljs-string">&#x27; &#x27;</span>);
  &#125;

  <span class="hljs-keyword">while</span> (delim) &#123;
    argv[argc++] = buf;
    *delim = <span class="hljs-string">&#x27;\0&#x27;</span>;
    buf = delim + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (*buf &amp;&amp; (*buf == <span class="hljs-string">&#x27; &#x27;</span>)) <span class="hljs-comment">/* ignore spaces */</span>
      buf++;

    <span class="hljs-keyword">if</span> (*buf == <span class="hljs-string">&#x27;\&#x27;&#x27;</span>) &#123;
      buf++;
      delim = <span class="hljs-built_in">strchr</span>(buf, <span class="hljs-string">&#x27;\&#x27;&#x27;</span>);
    &#125; <span class="hljs-keyword">else</span> &#123;
      delim = <span class="hljs-built_in">strchr</span>(buf, <span class="hljs-string">&#x27; &#x27;</span>);
    &#125;
  &#125;
  argv[argc] = <span class="hljs-literal">NULL</span>;

  <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">0</span>) <span class="hljs-comment">/* ignore blank line */</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;

  <span class="hljs-comment">/* should the job run in the background? */</span>
  <span class="hljs-keyword">if</span> ((bg = (*argv[argc - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;&amp;&#x27;</span>)) != <span class="hljs-number">0</span>) &#123;
    argv[--argc] = <span class="hljs-literal">NULL</span>;
  &#125;
  <span class="hljs-keyword">return</span> bg;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * builtin_cmd - If the user has typed a built-in command then execute</span>
<span class="hljs-comment"> *    it immediately.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">builtin_cmd</span><span class="hljs-params">(<span class="hljs-type">char</span> **argv)</span> &#123;
  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;quit&quot;</span>)) &#123;
	<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
  &#125;
  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>],<span class="hljs-string">&quot;jobs&quot;</span>)) &#123;
	listjobs(jobs);
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  &#125;
  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;bg&quot;</span>) || !<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>],<span class="hljs-string">&quot;fg&quot;</span>)) &#123;
	do_bgfg(argv);
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  &#125;
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* not a builtin command */</span>
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * do_bgfg - Execute the builtin bg and fg commands</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">do_bgfg</span><span class="hljs-params">(<span class="hljs-type">char</span> **argv)</span> &#123;

	<span class="hljs-type">int</span> jid;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">job_t</span> *<span class="hljs-title">job</span>;</span>
	<span class="hljs-keyword">if</span>(argv[<span class="hljs-number">1</span>]==<span class="hljs-literal">NULL</span>)&#123;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>,argv[<span class="hljs-number">0</span>]);
        <span class="hljs-keyword">return</span> ;
    &#125;
	<span class="hljs-keyword">if</span>(argv[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;%&#x27;</span>)&#123;
        jid=atoi(&amp;argv[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);
        job=getjobjid(jobs,jid);
        <span class="hljs-keyword">if</span>(job==<span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%%%d: No such job\n&quot;</span>,jid);
            <span class="hljs-keyword">return</span> ;
        &#125;
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isdigit</span>(argv[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]))&#123;
        jid = atoi(argv[<span class="hljs-number">1</span>]);        
        job=getjobjid(jobs,jid);
        <span class="hljs-keyword">if</span>(job==<span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%d): No such process\n&quot;</span>,jid);
            <span class="hljs-keyword">return</span> ;
        &#125;

    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>,argv[<span class="hljs-number">0</span>]);
        <span class="hljs-keyword">return</span> ;
    &#125;
	<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;bg&quot;</span>)) &#123;
        job-&gt;state=BG;
        kill(-(job-&gt;pid),SIGCONT);
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d] (%d) %s&quot;</span>, jid, job-&gt;pid, job-&gt;cmdline);
	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;fg&quot;</span>)) &#123;
		<span class="hljs-keyword">if</span> (job-&gt;state == ST) &#123;
			<span class="hljs-comment">//如果是挂起程序就重启并且转到前台，等待结束</span>
			job-&gt;state=FG;
            kill(-(job-&gt;pid),SIGCONT);
            waitfg(job-&gt;pid);
		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (job-&gt;state == BG) &#123;
			<span class="hljs-comment">//如果是后台程序就转到前台并等待结束</span>
			job-&gt;state=FG;
            waitfg(job-&gt;pid);
		&#125;
	&#125;
	<span class="hljs-keyword">return</span>;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * waitfg - Block until process pid is no longer the foreground process</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">waitfg</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid)</span> &#123;
  <span class="hljs-type">sigset_t</span> mask;
  sigemptyset(&amp;mask);
  <span class="hljs-keyword">while</span> (pid == fgpid(jobs))
    sigsuspend(&amp;mask);
  <span class="hljs-keyword">return</span>;
&#125;

<span class="hljs-comment">/*****************</span>
<span class="hljs-comment"> * Signal handlers</span>
<span class="hljs-comment"> *****************/</span>

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span>
<span class="hljs-comment"> *     a child job terminates (becomes a zombie), or stops because it</span>
<span class="hljs-comment"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span>
<span class="hljs-comment"> *     available zombie children, but doesn&#x27;t wait for any other</span>
<span class="hljs-comment"> *     currently running children to terminate.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">sigchld_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span> &#123;
  <span class="hljs-type">pid_t</span> pid;
  <span class="hljs-type">int</span> status;
  <span class="hljs-type">sigset_t</span> mask_all, prev;
  sigfillset(&amp;mask_all);
  <span class="hljs-keyword">while</span> ((pid = waitpid(<span class="hljs-number">-1</span>, &amp;status, WNOHANG | WUNTRACED)) &gt; <span class="hljs-number">0</span>) &#123;
    <span class="hljs-keyword">if</span> (WIFEXITED(status)) <span class="hljs-comment">// 正常退出 delete</span>
    &#123;
      sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev);
      deletejob(jobs, pid);
      sigprocmask(SIG_SETMASK, &amp;prev, <span class="hljs-literal">NULL</span>);
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (WIFSIGNALED(status)) <span class="hljs-comment">// 信号退出 delete</span>
    &#123;
      sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev);
      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Job [%d] (%d) terminated by signal %d\n&quot;</span>, pid2jid(pid), pid, WTERMSIG(status));
      deletejob(jobs, pid);
      sigprocmask(SIG_SETMASK, &amp;prev, <span class="hljs-literal">NULL</span>);
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (WIFSTOPPED(status)) &#123;
      sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev);
      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">job_t</span> *<span class="hljs-title">job</span>=</span>getjobpid(jobs,pid);
      job-&gt;state=ST;
      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Job [%d] (%d) stopped by signal %d\n&quot;</span>,pid2jid(pid),pid,WSTOPSIG(status));
      sigprocmask(SIG_SETMASK, &amp;prev, <span class="hljs-literal">NULL</span>);
    &#125;
  &#125;
  <span class="hljs-keyword">return</span>;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * sigint_handler - The kernel sends a SIGINT to the shell whenver the</span>
<span class="hljs-comment"> *    user types ctrl-c at the keyboard.  Catch it and send it along</span>
<span class="hljs-comment"> *    to the foreground job.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">sigint_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span> &#123;
	<span class="hljs-type">sigset_t</span> mask_all, prev;
	sigfillset(&amp;mask_all);
	sigprocmask(SIG_SETMASK, &amp;mask_all, &amp;prev);
	<span class="hljs-type">pid_t</span> pid = fgpid(jobs);
	<span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>) &#123;
		kill(-pid,sig);
	&#125;
    sigprocmask(SIG_SETMASK, &amp;prev, <span class="hljs-literal">NULL</span>);
	<span class="hljs-keyword">return</span>;
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever</span>
<span class="hljs-comment"> *     the user types ctrl-z at the keyboard. Catch it and suspend the</span>
<span class="hljs-comment"> *     foreground job by sending it a SIGTSTP.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">sigtstp_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span> &#123;
	<span class="hljs-type">sigset_t</span> mask_all, prev;
	sigfillset(&amp;mask_all);
	sigprocmask(SIG_SETMASK, &amp;mask_all, &amp;prev);
	<span class="hljs-type">pid_t</span> pid = fgpid(jobs);
	<span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>) &#123;
		kill(-pid,sig);
	&#125;
    sigprocmask(SIG_SETMASK, &amp;prev, <span class="hljs-literal">NULL</span>);
	<span class="hljs-keyword">return</span>;
&#125;

<span class="hljs-comment">/*********************</span>
<span class="hljs-comment"> * End signal handlers</span>
<span class="hljs-comment"> *********************/</span>

<span class="hljs-comment">/***********************************************</span>
<span class="hljs-comment"> * Helper routines that manipulate the job list</span>
<span class="hljs-comment"> **********************************************/</span>

<span class="hljs-comment">/* clearjob - Clear the entries in a job struct */</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">clearjob</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">job_t</span> *job)</span> &#123;
  job-&gt;pid = <span class="hljs-number">0</span>;
  job-&gt;jid = <span class="hljs-number">0</span>;
  job-&gt;state = UNDEF;
  job-&gt;cmdline[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;
&#125;

<span class="hljs-comment">/* initjobs - Initialize the job list */</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">initjobs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">job_t</span> *jobs)</span> &#123;
  <span class="hljs-type">int</span> i;

  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++)
    clearjob(&amp;jobs[i]);
&#125;

<span class="hljs-comment">/* maxjid - Returns largest allocated job ID */</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">maxjid</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">job_t</span> *jobs)</span> &#123;
  <span class="hljs-type">int</span> i, max = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++)
    <span class="hljs-keyword">if</span> (jobs[i].jid &gt; max)
      max = jobs[i].jid;
  <span class="hljs-keyword">return</span> max;
&#125;

<span class="hljs-comment">/* addjob - Add a job to the job list */</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">addjob</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">job_t</span> *jobs, <span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> state, <span class="hljs-type">char</span> *cmdline)</span> &#123;
  <span class="hljs-type">int</span> i;

  <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">1</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++) &#123;
    <span class="hljs-keyword">if</span> (jobs[i].pid == <span class="hljs-number">0</span>) &#123;
      jobs[i].pid = pid;
      jobs[i].state = state;
      jobs[i].jid = nextjid++;
      <span class="hljs-keyword">if</span> (nextjid &gt; MAXJOBS)
        nextjid = <span class="hljs-number">1</span>;
      <span class="hljs-built_in">strcpy</span>(jobs[i].cmdline, cmdline);
      <span class="hljs-keyword">if</span> (verbose) &#123;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Added job [%d] %d %s\n&quot;</span>, jobs[i].jid, jobs[i].pid,
               jobs[i].cmdline);
      &#125;
      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    &#125;
  &#125;
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Tried to create too many jobs\n&quot;</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-comment">/* deletejob - Delete a job whose PID=pid from the job list */</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">deletejob</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">job_t</span> *jobs, <span class="hljs-type">pid_t</span> pid)</span> &#123;
  <span class="hljs-type">int</span> i;

  <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">1</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++) &#123;
    <span class="hljs-keyword">if</span> (jobs[i].pid == pid) &#123;
      clearjob(&amp;jobs[i]);
      nextjid = maxjid(jobs) + <span class="hljs-number">1</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    &#125;
  &#125;
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-comment">/* fgpid - Return PID of current foreground job, 0 if no such job */</span>
<span class="hljs-type">pid_t</span> <span class="hljs-title function_">fgpid</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">job_t</span> *jobs)</span> &#123;
  <span class="hljs-type">int</span> i;

  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++)
    <span class="hljs-keyword">if</span> (jobs[i].state == FG)
      <span class="hljs-keyword">return</span> jobs[i].pid;
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-comment">/* getjobpid  - Find a job (by PID) on the job list */</span>
<span class="hljs-keyword">struct</span> <span class="hljs-type">job_t</span> *<span class="hljs-title function_">getjobpid</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">job_t</span> *jobs, <span class="hljs-type">pid_t</span> pid)</span> &#123;
  <span class="hljs-type">int</span> i;

  <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">1</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++)
    <span class="hljs-keyword">if</span> (jobs[i].pid == pid)
      <span class="hljs-keyword">return</span> &amp;jobs[i];
  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
&#125;

<span class="hljs-comment">/* getjobjid  - Find a job (by JID) on the job list */</span>
<span class="hljs-keyword">struct</span> <span class="hljs-type">job_t</span> *<span class="hljs-title function_">getjobjid</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">job_t</span> *jobs, <span class="hljs-type">int</span> jid)</span> &#123;
  <span class="hljs-type">int</span> i;

  <span class="hljs-keyword">if</span> (jid &lt; <span class="hljs-number">1</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++)
    <span class="hljs-keyword">if</span> (jobs[i].jid == jid)
      <span class="hljs-keyword">return</span> &amp;jobs[i];
  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
&#125;

<span class="hljs-comment">/* pid2jid - Map process ID to job ID */</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">pid2jid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid)</span> &#123;
  <span class="hljs-type">int</span> i;

  <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">1</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++)
    <span class="hljs-keyword">if</span> (jobs[i].pid == pid) &#123;
      <span class="hljs-keyword">return</span> jobs[i].jid;
    &#125;
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-comment">/* listjobs - Print the job list */</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">listjobs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">job_t</span> *jobs)</span> &#123;
  <span class="hljs-type">int</span> i;

  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXJOBS; i++) &#123;
    <span class="hljs-keyword">if</span> (jobs[i].pid != <span class="hljs-number">0</span>) &#123;
      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d] (%d) &quot;</span>, jobs[i].jid, jobs[i].pid);
      <span class="hljs-keyword">switch</span> (jobs[i].state) &#123;
      <span class="hljs-keyword">case</span> BG:
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Running &quot;</span>);
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> FG:
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Foreground &quot;</span>);
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> ST:
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Stopped &quot;</span>);
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">default</span>:
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;listjobs: Internal error: job[%d].state=%d &quot;</span>, i, jobs[i].state);
      &#125;
      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, jobs[i].cmdline);
    &#125;
  &#125;
&#125;
<span class="hljs-comment">/******************************</span>
<span class="hljs-comment"> * end job list helper routines</span>
<span class="hljs-comment"> ******************************/</span>

<span class="hljs-comment">/***********************</span>
<span class="hljs-comment"> * Other helper routines</span>
<span class="hljs-comment"> ***********************/</span>

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * usage - print a help message</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">usage</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage: shell [-hvp]\n&quot;</span>);
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   -h   print this message\n&quot;</span>);
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   -v   print additional diagnostic information\n&quot;</span>);
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   -p   do not emit a command prompt\n&quot;</span>);
  <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * unix_error - unix-style error routine</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">unix_error</span><span class="hljs-params">(<span class="hljs-type">char</span> *msg)</span> &#123;
  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stdout</span>, <span class="hljs-string">&quot;%s: %s\n&quot;</span>, msg, strerror(errno));
  <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * app_error - application-style error routine</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">app_error</span><span class="hljs-params">(<span class="hljs-type">char</span> *msg)</span> &#123;
  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stdout</span>, <span class="hljs-string">&quot;%s\n&quot;</span>, msg);
  <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * Signal - wrapper for the sigaction function</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">handler_t</span> *<span class="hljs-title function_">Signal</span><span class="hljs-params">(<span class="hljs-type">int</span> signum, <span class="hljs-type">handler_t</span> *handler)</span> &#123;
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">action</span>, <span class="hljs-title">old_action</span>;</span>

  action.sa_handler = handler;
  sigemptyset(&amp;action.sa_mask); <span class="hljs-comment">/* block sigs of type being handled */</span>
  action.sa_flags = SA_RESTART; <span class="hljs-comment">/* restart syscalls if possible */</span>

  <span class="hljs-keyword">if</span> (sigaction(signum, &amp;action, &amp;old_action) &lt; <span class="hljs-number">0</span>)
    unix_error(<span class="hljs-string">&quot;Signal error&quot;</span>);
  <span class="hljs-keyword">return</span> (old_action.sa_handler);
&#125;

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * sigquit_handler - The driver program can gracefully terminate the</span>
<span class="hljs-comment"> *    child shell by sending it a SIGQUIT signal.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">sigquit_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span> &#123;
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Terminating after receipt of SIGQUIT signal\n&quot;</span>);
  <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
&#125;
</code></pre></div>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/CSAPP/">CSAPP</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/02/05/CSAPP/10-MallocLab/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">10-MallocLab</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/02/03/CSAPP/08-PerformanceLab/">
                        <span class="hidden-mobile">08-PerformanceLab</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  










  

  
    <!-- KaTeX -->
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css" />
  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>

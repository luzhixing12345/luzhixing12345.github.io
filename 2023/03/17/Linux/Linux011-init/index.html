

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
  <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#4a00e0">
  <meta name="author" content="luzhixing12345">
  <meta name="keywords" content="">
  
    <meta name="description" content="环境配置  关于Linux0.11的基础部分主要参考 《Linux内核完全注释》 一书, 写的非常好, 十分建议阅读!  关于基础环境的搭建我觉得应该不用赘述了, 我个人倾向于 VMware + Vscode + SSH  Linux0.11 早期的Linux代码被保存在 http:&#x2F;&#x2F;oldlinux.org&#x2F; 上, 其中还保存着一些诸如 VMware-images 和 qemu-images">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux0.11-init">
<meta property="og:url" content="https://luzhixing12345.github.io/2023/03/17/Linux/Linux011-init/index.html">
<meta property="og:site_name" content="kamilu的博客">
<meta property="og:description" content="环境配置  关于Linux0.11的基础部分主要参考 《Linux内核完全注释》 一书, 写的非常好, 十分建议阅读!  关于基础环境的搭建我觉得应该不用赘述了, 我个人倾向于 VMware + Vscode + SSH  Linux0.11 早期的Linux代码被保存在 http:&#x2F;&#x2F;oldlinux.org&#x2F; 上, 其中还保存着一些诸如 VMware-images 和 qemu-images">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/learner-lu/picbed/master/20230317180110.png">
<meta property="og:image" content="https://raw.githubusercontent.com/learner-lu/picbed/master/20230321145946.png">
<meta property="og:image" content="https://raw.githubusercontent.com/learner-lu/picbed/master/20230322135932.png">
<meta property="og:image" content="https://raw.githubusercontent.com/learner-lu/picbed/master/20230322140833.png">
<meta property="og:image" content="https://raw.githubusercontent.com/learner-lu/picbed/master/20230322153449.png">
<meta property="og:image" content="https://raw.githubusercontent.com/learner-lu/picbed/master/20230323171144.png">
<meta property="og:image" content="https://raw.githubusercontent.com/learner-lu/picbed/master/20230323170440.png">
<meta property="article:published_time" content="2023-03-17T07:37:23.000Z">
<meta property="article:modified_time" content="2023-03-23T09:26:25.889Z">
<meta property="article:author" content="luzhixing12345">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://raw.githubusercontent.com/learner-lu/picbed/master/20230317180110.png">
  
  
  <title>Linux0.11-init - kamilu的博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"luzhixing12345.github.io","root":"/","version":"1.8.14","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"fEy8W8VvIoc26nT53dV2157j-gzGzoHsz","app_key":"s9HXuqmvBWrOaAiLA07Jg59A","server_url":"https://fey8w8vv.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":true}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Kamilu-blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://raw.githubusercontent.com/learner-lu/picbed/master/background.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Linux0.11-init">
              
                Linux0.11-init
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2023-03-17 15:37" pubdate>
        2023年3月17日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      9.6k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      80 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Linux0.11-init</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：1 个月前
                
              </p>
            
            <div class="markdown-body">
              <h2 id="环境配置"><a class="markdownIt-Anchor" href="#环境配置"></a> 环境配置</h2>
<blockquote>
<p>关于Linux0.11的基础部分主要参考 《Linux内核完全注释》 一书, 写的非常好, 十分建议阅读!</p>
</blockquote>
<p>关于基础环境的搭建我觉得应该不用赘述了, 我个人倾向于 <a href="https://luzhixing12345.github.io/2023/02/28/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/VMware%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE/">VMware + Vscode + SSH</a></p>
<h2 id="linux011"><a class="markdownIt-Anchor" href="#linux011"></a> Linux0.11</h2>
<p>早期的Linux代码被保存在 <a target="_blank" rel="noopener" href="http://oldlinux.org/">http://oldlinux.org/</a> 上, 其中还保存着一些诸如 <a target="_blank" rel="noopener" href="http://www.oldlinux.org/Linux.old/VMware-images/">VMware-images</a> 和 <a target="_blank" rel="noopener" href="http://www.oldlinux.org/Linux.old/qemu-images/">qemu-images</a></p>
<p>源码下载只需要找到其中的0.11版本的即可</p>
<div class="code-wrapper"><pre><code class="hljs bash">wget http://www.oldlinux.org/Linux.old/Linux-0.11/sources/system/linux-0.11.tar.Z
tar xf linux-0.11.tar.Z</code></pre></div>
<p>解压之后的文件夹比较清晰</p>
<div class="code-wrapper"><pre><code class="hljs bash">├── boot          系统引导汇编程序
├── fs            文件系统
├── include       头文件
│   ├── asm       与CPU体系结构相关的部分
│   ├── linux     Linux内核专用部分
│   └── sys       系统数据结构部分
├── init          内核初始化程序
├── kernel        内核进程调度 信号处理 系统调用
│   ├── blk_drv   块设备驱动程序
│   ├── chr_drv   字符设备驱动程序
│   └── math      数学协处理器仿真处理程序
├── lib           内核库函数
├── mm            内存管理程序
└── tools         生成内核Image文件的工具程序</code></pre></div>
<p>不要忘记添加一下头文件路径, 如果是使用的Microsoft的C/C++插件可以添加 <code>.vscode/c_cpp_properties.json</code></p>
<div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>
    <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
        <span class="hljs-punctuation">&#123;</span>
            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Linux&quot;</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">&quot;includePath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
                <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span><span class="hljs-punctuation">,</span>
                <span class="hljs-string">&quot;include/&quot;</span>
            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">&quot;defines&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">&quot;compilerPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/usr/bin/gcc&quot;</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">&quot;cStandard&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;c17&quot;</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">&quot;cppStandard&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;c++98&quot;</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">&quot;intelliSenseMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;linux-gcc-x64&quot;</span>
        <span class="hljs-punctuation">&#125;</span>
    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span>
<span class="hljs-punctuation">&#125;</span></code></pre></div>
<p>如果是clangd就添加 <code>.vscode/settings.json</code></p>
<div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>
    <span class="hljs-attr">&quot;clangd.fallbackFlags&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
        <span class="hljs-string">&quot;include/&quot;</span>
    <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">&#125;</span></code></pre></div>
<h2 id="编译过程"><a class="markdownIt-Anchor" href="#编译过程"></a> 编译过程</h2>
<p>把内核从块设备引导加载到内存, 对系统配置参数进行探测, 完成了进入32位保护模式运行之前的所有工作, 位内核系统执行进一步的初始化工作做准备</p>
<ul>
<li>bootsect.s =&gt; 磁盘引导程序</li>
<li>setup.s =&gt; 获取BIOS参数</li>
<li>head.s =&gt; 运行启动代码程序</li>
</ul>
<p>Makefile中核心编译环节</p>
<div class="code-wrapper"><pre><code class="hljs Makefile"><span class="hljs-section">all: Image</span>

<span class="hljs-comment"># 依赖四个文件 =&gt; boot/bootsect boot/setup tools/system tools/build</span>
<span class="hljs-comment"># 是用build 以 $(ROOT_DEV) 为根文件系统设备将其他部分组装成内核映像文件 Image</span>
<span class="hljs-section">Image: boot/bootsect boot/setup tools/system tools/build</span>
	tools/build boot/bootsect boot/setup tools/system <span class="hljs-variable">$(ROOT_DEV)</span> &gt; Image
	sync
<span class="hljs-comment"># sync : 同步命令, 迫使缓冲块数据立即写盘并更新超级快</span></code></pre></div>
<p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230317180110.png" srcset="/img/loading.gif" lazyload alt="20230317180110" /></p>
<p>其中Image依赖的四个文件<code>boot/bootsect</code> <code>boot/setup</code> <code>tools/system</code> <code>tools/build</code>分别对应的Makefile规则如下</p>
<div class="code-wrapper"><pre><code class="hljs Makefile"><span class="hljs-section">boot/bootsect:	boot/bootsect.s</span>
	<span class="hljs-variable">$(AS86)</span> -o boot/bootsect.o <span class="hljs-variable">$^</span>
	<span class="hljs-variable">$(LD86)</span> -s -o <span class="hljs-variable">$@</span> boot/bootsect.o

<span class="hljs-section">boot/setup: boot/setup.s</span>
	<span class="hljs-variable">$(AS86)</span> -o boot/setup.o <span class="hljs-variable">$^</span>
	<span class="hljs-variable">$(LD86)</span> -s -o <span class="hljs-variable">$@</span> boot/setup.o

<span class="hljs-section">tools/system: boot/head.o init/main.o <span class="hljs-variable">$(ARCHIVES)</span> <span class="hljs-variable">$(DRIVERS)</span> <span class="hljs-variable">$(MATH)</span> <span class="hljs-variable">$(LIBS)</span></span>
	<span class="hljs-variable">$(LD)</span> <span class="hljs-variable">$(LDFLAGS)</span> <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span> &gt; System.map

<span class="hljs-section">tools/build: tools/build.c</span>
	<span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$^</span></code></pre></div>
<p>这里的 <code>System.map</code> 用于存放内核符号表信息, 当内核运行出错的时候可以通过 System.map 中的符号表解析查到一个地址对应的变量名, 或反过来通过变量名查到地址</p>
<h2 id="引导启动程序"><a class="markdownIt-Anchor" href="#引导启动程序"></a> 引导启动程序</h2>
<blockquote>
<p>引导启动这部分和硬件关系很大, 读不懂理解不了很正常, 跳过此部分直接进入C代码也可以</p>
</blockquote>
<p>bootsect.s 和 setup.s 采用近似于 Intel 的汇编语言语法, 需要使用 Intel 8086汇编编译器和链接器as86 ld86</p>
<p>head.s 使用GNU汇编程序格式, 运行在保护模式下, 需要使用 GNU 的as进行编译, 这是一种 AT&amp;T的汇编语言程序</p>
<p>笔者这里实在是不想过多讨论汇编相关的内容, 一个原因是确实枯燥乏味, 一个原因是需要很多硬件相关的前置知识, 最主要的原因是这并不是我关心的问题. 操作系统跑起来很重要但是跑的稳更重要, 深究启动细节或许有些意义, 但对我来说意义不大</p>
<p>下面主要来讨论一下实模式和保护模式</p>
<p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230321145946.png" srcset="/img/loading.gif" lazyload alt="20230321145946" /></p>
<ul>
<li>
<p>实模式: 如左图, 寻址一个内存地址使用段+偏移值, 也就是ds:si, 段值保存在段寄存器ds当中, 段内偏移地址保存在第一可以寻址的寄存器当中(si), 这两个都是16位寄存器, 对应的大小是64KB, 所以偏移地址的范围就是[0,64KB), 所以段的最大长度是64KB.</p>
</li>
<li>
<p>保护模式: 如右图, 寻址一个内存地址仍然是使用段+偏移值, 不过与实模式不同的是, ds并不会直接保存段的地址, 而是保存一个指向全局描述符表(gdt, global descriptor table) 的索引</p>
<p>gdt中保存着所有的段的信息, 包括内存段的基地址, 偏移值, 段最大长度</p>
<p>gdt的基地址在gdtr, ds保存一个索引值, 可以使用类似 gdt[ds]的方式得到所需段的基地址</p>
<p>这样的方式有一些好处, 首先是段的长度可变, 而不是固定死的64KB, 这样变大变小都可以灵活的调整</p>
</li>
</ul>
<p>在 boot/setup.s 中相关的汇编如下</p>
<div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-symbol">end_move:</span>
	<span class="hljs-keyword">mov</span>	<span class="hljs-built_in">ax</span>,#SETUPSEG	! right, forgot this <span class="hljs-meta">at</span> first. didn<span class="hljs-string">&#x27;t work :-)</span>
<span class="hljs-string">	mov	ds,ax           ! ds 指向本程序的setup段</span>
<span class="hljs-string">	lidt	idt_48		! load idt with 0,0</span>
<span class="hljs-string">	lgdt	gdt_48		! load gdt with whatever appropriate</span>
<span class="hljs-string"></span>
<span class="hljs-string">idt_48:</span>
<span class="hljs-string">	.word	0			! idt limit=0</span>
<span class="hljs-string">	.word	0,0			! idt base=0L</span>
<span class="hljs-string"></span>
<span class="hljs-string">gdt_48:</span>
<span class="hljs-string">	.word	0x800		! gdt limit=2048, 256 GDT entries</span>
<span class="hljs-string">	.word	512+gdt,0x9	! gdt base = 0X9xxxx</span></code></pre></div>
<p>引导加载程序 bootsect.s 将 setup.s 代码和 system 模块加载到了内存中, 兵器而分别把自己和 setup.s 代码移动到了物理内存,0x90000 和 0x90200 处后, 就把执行权交给了 setup 程序, 其中 system 模块的首部包含有 head.s 代码</p>
<p>setup 程序的主要作用是利用 ROM BIOS 的中断程序去获取机器的一些基本参数, 并保存在 0x90000 开始的内存块中, 以供后面程序使用… 同时把 system 模块向下移动到物理地址 0x00000 开始处, 这样 system 中的head.s 代码就被移动到 0x00000  处了</p>
<p>然后加载描述符表基地址到描述符表寄存器中, 为进行32为保护模式下的运行做好准备, 接下来对终端控制引荐进行重新设备, 最后通过设计机器控制寄存器 CR0 并跳转到 system 模块的 head.s 代码开始处, 使 CPU 进入32位保护模式下运行</p>
<p>head.s 代码主要作用是初步初始化中断描述符表中256项门描述符, 检查 A20 地址线是否打开, 测试系统是否含有数学协处理器. 然后初始化内存也目录表, 为内存的分页管理做好准备工作</p>
<p>最后跳转到system模块中的初始化程序 init.c 中继续执行</p>
<h2 id="init"><a class="markdownIt-Anchor" href="#init"></a> init</h2>
<h3 id="系统调用的过程"><a class="markdownIt-Anchor" href="#系统调用的过程"></a> 系统调用的过程</h3>
<p>下面这四句用了宏 _syscall0 _syscall1 去展开, 相当于 int fork() {…} 这种定义方式</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> _syscall0(<span class="hljs-type">int</span>, fork);
<span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> _syscall0(<span class="hljs-type">int</span>, pause);
<span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> _syscall1(<span class="hljs-type">int</span>, setup, <span class="hljs-type">void</span>*, BIOS);
<span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> _syscall0(<span class="hljs-type">int</span>, sync);</code></pre></div>
<p>其中宏展开可以看到内嵌的汇编代码分别如下</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _syscall0(type, name)                                           \</span>
<span class="hljs-meta">    type name(void) &#123;                                                   \</span>
<span class="hljs-meta">        long __res;                                                     \</span>
<span class="hljs-meta">        __asm__ volatile(<span class="hljs-string">&quot;int $0x80&quot;</span> : <span class="hljs-string">&quot;=a&quot;</span>(__res) : <span class="hljs-string">&quot;0&quot;</span>(__NR_##name)); \</span>
<span class="hljs-meta">        <span class="hljs-keyword">if</span> (__res &gt;= 0) return (type)__res;                             \</span>
<span class="hljs-meta">        errno = -__res;                                                 \</span>
<span class="hljs-meta">        return -1;                                                      \</span>
<span class="hljs-meta">    &#125;</span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> _syscall1(type, name, atype, a)                       \</span>
<span class="hljs-meta">    type name(atype a) &#123;                                      \</span>
<span class="hljs-meta">        long __res;                                           \</span>
<span class="hljs-meta">        __asm__ volatile(<span class="hljs-string">&quot;int $0x80&quot;</span>                          \</span>
<span class="hljs-meta">                         : <span class="hljs-string">&quot;=a&quot;</span>(__res)                        \</span>
<span class="hljs-meta">                         : <span class="hljs-string">&quot;0&quot;</span>(__NR_##name), <span class="hljs-string">&quot;b&quot;</span>((long)(a))); \</span>
<span class="hljs-meta">        <span class="hljs-keyword">if</span> (__res &gt;= 0) return (type)__res;                   \</span>
<span class="hljs-meta">        errno = -__res;                                       \</span>
<span class="hljs-meta">        return -1;                                            \</span>
<span class="hljs-meta">    &#125;</span></code></pre></div>
<p>在 <code>include/sys/unistd.h</code> 中我们可看到如下定义的宏</p>
<p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230322135932.png" srcset="/img/loading.gif" lazyload alt="20230322135932" /></p>
<p>所以根据对应的映射宏<code>__NR_##name</code>展开, 即扩展得到</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;
    <span class="hljs-type">long</span> __res;
    __asm__ <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;int $0x80&quot;</span> : <span class="hljs-string">&quot;=a&quot;</span>(__res) : <span class="hljs-string">&quot;0&quot;</span>(<span class="hljs-number">2</span>))</span>;
    <span class="hljs-keyword">if</span> (__res &gt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)__res;
    errno = -__res;
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
&#125;

<span class="hljs-type">int</span> <span class="hljs-title function_">setup</span><span class="hljs-params">(<span class="hljs-type">void</span>* BIOS)</span> &#123;
    <span class="hljs-type">long</span> __res;
    __asm__ <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;int $0x80&quot;</span> : <span class="hljs-string">&quot;=a&quot;</span>(__res) : <span class="hljs-string">&quot;0&quot;</span>(<span class="hljs-number">0</span>), <span class="hljs-string">&quot;b&quot;</span>((<span class="hljs-type">long</span>)(BIOS)))</span>;
    <span class="hljs-keyword">if</span> (__res &gt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)__res;
    errno = -__res;
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
&#125;</code></pre></div>
<p>这两个函数是通过在 Linux 内核中使用中断 (interrupt) 0x80 来调用系统调用 (system call) 的方式实现的。系统调用是操作系统提供给应用程序的一组接口，应用程序可以通过这些接口来请求操作系统执行特定的操作。</p>
<p>在这两个函数中，<code>asm volatile(&quot;int $0x80&quot;)</code> 的作用是使用内联汇编 (inline assembly) 在代码中嵌入一个汇编指令，将中断 0x80 发送给处理器。这个中断号是 Linux 内核中指向系统调用处理程序的入口点。</p>
<p>__res 变量是用来保存返回值的，通过 “=a”(__res) 表示将 EAX 寄存器中的值赋给 __res 变量。</p>
<p>第一个函数中，“0”(2) 表示将函数调用号 2 (在 Linux 中是 fork() 的函数调用号) 赋给 EAX 寄存器。</p>
<p>第二个函数中，“0”(0) 表示将函数调用号 0 (在 Linux 中是 setup() 的函数调用号) 赋给 EAX 寄存器，“b”((long)(BIOS)) 表示将 BIOS 参数的地址放入 EBX 寄存器中。</p>
<p>接下来，如果返回值大于等于 0，说明系统调用执行成功，将 __res 强制转换为 int 类型并返回。如果返回值小于 0，将 -__res 赋给 errno 变量，并返回 -1，表示系统调用执行失败。</p>
<p>这里的 fork 对应的索引值为 2, setup 对应的索引值为 0, 与此同时我们可以看到 <code>include/linux/sys.h</code> 下的所有系统调用sys_call_table</p>
<p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230322140833.png" srcset="/img/loading.gif" lazyload alt="20230322140833" /></p>
<p>所以简而言之, 当我们使用fork函数的时候</p>
<ul>
<li>
<p>fork函数借助其内联汇编: <code>__asm__ volatile(&quot;int $0x80&quot; : &quot;=a&quot;(__res) : &quot;0&quot;(2));</code>, 中断 0x80 发送给处理器</p>
</li>
<li>
<p>CPU接收到中断信号, 转去调用idt的第2号中断, 也就是 <code>_sys_fork</code></p>
</li>
<li>
<p>在 init/main.c 的 main 函数中的 sche_init 初始化的时候设置了相关的中断向量表, 查找到2号中断</p>
<div class="code-wrapper"><pre><code class="hljs c">set_tss_desc(gdt+FIRST_TSS_ENTRY,&amp;(init_task.task.tss));
set_ldt_desc(gdt+FIRST_LDT_ENTRY,&amp;(init_task.task.ldt));</code></pre></div>
</li>
<li>
<p><code>_sys_fork</code> 的实现在 kernel/system_call.s 的汇编代码中</p>
<div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-symbol">_sys_fork:</span>
	<span class="hljs-keyword">call</span> _find_empty_process
	testl %eax,%eax
	<span class="hljs-keyword">js</span> 1f
	<span class="hljs-keyword">push</span> %gs
	pushl %esi
	pushl %edi
	pushl %ebp
	pushl %eax
	<span class="hljs-keyword">call</span> _copy_process
	addl <span class="hljs-number">$20</span>,%esp
<span class="hljs-number">1</span>:	<span class="hljs-keyword">ret</span></code></pre></div>
</li>
<li>
<p>其中汇编中的两个函数 <code>_find_empty_process</code> <code>_copy_process</code> 的去掉前缀下划线的函数实现可以在 <code>kernel/fork.c</code> 中找到</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">copy_process</span><span class="hljs-params">(<span class="hljs-type">int</span> nr, <span class="hljs-type">long</span> ebp, <span class="hljs-type">long</span> edi, <span class="hljs-type">long</span> esi, <span class="hljs-type">long</span> gs, <span class="hljs-type">long</span> none,</span>
<span class="hljs-params">               <span class="hljs-type">long</span> ebx, <span class="hljs-type">long</span> ecx, <span class="hljs-type">long</span> edx, <span class="hljs-type">long</span> fs, <span class="hljs-type">long</span> es, <span class="hljs-type">long</span> ds,</span>
<span class="hljs-params">               <span class="hljs-type">long</span> eip, <span class="hljs-type">long</span> cs, <span class="hljs-type">long</span> eflags, <span class="hljs-type">long</span> esp, <span class="hljs-type">long</span> ss)</span> &#123;
                  ...
               &#125;
<span class="hljs-type">int</span> <span class="hljs-title function_">find_empty_process</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;
  <span class="hljs-type">int</span> i;

repeat:
    <span class="hljs-keyword">if</span> ((++last_pid) &lt; <span class="hljs-number">0</span>)
        last_pid = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NR_TASKS; i++)
        <span class="hljs-keyword">if</span> (task[i] &amp;&amp; task[i]-&gt;pid == last_pid)
            <span class="hljs-keyword">goto</span> repeat;
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; NR_TASKS; i++)
        <span class="hljs-keyword">if</span> (!task[i])
            <span class="hljs-keyword">return</span> i;
    <span class="hljs-keyword">return</span> -EAGAIN;
&#125;</code></pre></div>
</li>
<li>
<p>全部完成调用之后返回结果: <code>if (__res &gt;= 0) return (type)__res;</code>, 或返回错误信息</p>
</li>
</ul>
<h3 id="main函数部分"><a class="markdownIt-Anchor" href="#main函数部分"></a> main函数部分</h3>
<p>main函数的核心部分如下所示, 首先做了一些地址的初始化, 然后初始化各方面的硬件设备. 然后fork一个子进程执行init, 结束之后使用pause等待进程调度</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;
    <span class="hljs-comment">// 一些内存地址的初始化</span>
    mem_init(main_memory_start, memory_end);  <span class="hljs-comment">// 内存初始化     -&gt; mm/memory.c</span>
    trap_init();     <span class="hljs-comment">// 中断向量初始化 -&gt; kernel/traps.c</span>
    blk_dev_init();  <span class="hljs-comment">// 块设备初始化   -&gt; kernel/blk_drv/ll_rw_blk.c</span>
    chr_dev_init();  <span class="hljs-comment">// 字符设备初始化 -&gt; kernel/chr_drv/tty_io.c</span>
    tty_init();      <span class="hljs-comment">// tty初始化    -&gt; kernel/chr_drv/tty_io.c</span>
    time_init();     <span class="hljs-comment">// 开机时间初始化</span>
    sched_init();    <span class="hljs-comment">// 调度程序初始化 -&gt; kernel/sched.c</span>
    buffer_init(buffer_memory_end);  <span class="hljs-comment">// 缓冲管理初始化 -&gt; fs/buffer.c</span>
    hd_init();            <span class="hljs-comment">// 硬盘初始化     -&gt; kernel/blk_drv/hd.c</span>
    floppy_init();        <span class="hljs-comment">// 软驱初始化     -&gt; kernel/blk_drv/floppy.c</span>
    sti();                <span class="hljs-comment">// 所有初始化工作结束之后开启中断</span>
    move_to_user_mode();  <span class="hljs-comment">// 进入用户模式</span>

    <span class="hljs-keyword">if</span> (!fork()) &#123;
        init();
    &#125;
    <span class="hljs-keyword">for</span> (;;) pause();
&#125;</code></pre></div>
<p>各部分初始化之后 , 系统已经处理可以运行的状态了, 这时候操作系统进入用户态 <code>move_to_user_mode</code>, 将自己移至任务0(进程0)中, 并且使用 fork 创建进程1 (init进程)</p>
<hr />
<p>这里要注意到是, 由于fork创建新进程的过程是通过完全复制父进程代码段和数据段的方式实现的, 因此在首次使用 fork创建新进程并执行 init 时, 为了确保新进程用户态堆栈没有进程 0 的多余信息, 要求进程 0 在创建首个新进程之前不要使用用户态堆栈, <strong>即要求任务0不要调用函数</strong></p>
<p>因此在 main.c 主函数移动到任务0执行之后, 任务0 中的代码fork不能以函数的形式进行调用, 所以使用了 gcc 函数内嵌汇编的方式</p>
<p>任务0 的pause 也是内联汇编, 因为无法确定父进程和子进程的调用顺序, 所以需要保证这里也不会使用用户态堆栈</p>
<hr />
<p>init中的任务也并不复杂</p>
<ul>
<li>使用 <code>setup((void*)&amp;drive_info)</code> 安装根文件系统设备</li>
<li>打开设备tty0, 创建终端标准 IO stdin stdout stderr
<ul>
<li>再次fork在子进程中将终端输入定向到 rc</li>
</ul>
</li>
<li>再次fork一个子进程,新建会话开启 /bin/sh. 如果子进程退出则父进程进入死循环继续生成子进程, 等待</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;
    <span class="hljs-type">int</span> pid, i;
    <span class="hljs-comment">// setup 是一个系统调用</span>
    <span class="hljs-comment">// 读取硬盘参数包括分区表信息, 加载虚拟盘, 安装根文件系统设备</span>
    setup((<span class="hljs-type">void</span>*)&amp;drive_info);
    <span class="hljs-comment">// 以读写访问方式打开 tty0</span>
    (<span class="hljs-type">void</span>)open(<span class="hljs-string">&quot;/dev/tty0&quot;</span>, O_RDWR, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 0 -&gt; stdin</span>
    (<span class="hljs-type">void</span>)dup(<span class="hljs-number">0</span>);                        <span class="hljs-comment">// 复制句柄1号 -&gt; stdout</span>
    (<span class="hljs-type">void</span>)dup(<span class="hljs-number">0</span>);                        <span class="hljs-comment">// 复制句柄2号 -&gt; stderr</span>
    <span class="hljs-comment">// 缓冲区块数</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d buffers = %d bytes buffer space\n\r&quot;</span>, NR_BUFFERS,
           NR_BUFFERS * BLOCK_SIZE);
    <span class="hljs-comment">// 内存总字节数</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Free mem: %d bytes\n\r&quot;</span>, memory_end - main_memory_start);
    <span class="hljs-comment">// fork 的子进程返回 0</span>
    <span class="hljs-comment">//        父进程返回子进程 pid</span>
    <span class="hljs-comment">// 这里只执行子进程</span>
    <span class="hljs-keyword">if</span> (!(pid = fork())) &#123;
        close(<span class="hljs-number">0</span>);                          <span class="hljs-comment">// 关闭 stdin</span>
        <span class="hljs-keyword">if</span> (open(<span class="hljs-string">&quot;/etc/rc&quot;</span>, O_RDONLY, <span class="hljs-number">0</span>))  <span class="hljs-comment">// 只读打开 /etc/rc</span>
            _exit(<span class="hljs-number">1</span>);
        execve(<span class="hljs-string">&quot;/bin/sh&quot;</span>, argv_rc, envp_rc);  <span class="hljs-comment">// 将进程自身替换成 /bin/sh 程序,</span>
                                              <span class="hljs-comment">// 参数使用的是 argv_rc envp_rc</span>
        _exit(<span class="hljs-number">2</span>);  <span class="hljs-comment">// 1: 操作未许可 2: 文件/目录不存在</span>
    &#125;
    <span class="hljs-comment">// 父进程等待子进程结束</span>
    <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>)
        <span class="hljs-keyword">while</span> (pid != wait(&amp;i)) <span class="hljs-comment">/* nothing */</span>
            ;
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;
        <span class="hljs-comment">// 创建子进程失败</span>
        <span class="hljs-keyword">if</span> ((pid = fork()) &lt; <span class="hljs-number">0</span>) &#123;
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Fork failed in init\r\n&quot;</span>);
            <span class="hljs-keyword">continue</span>;
        &#125;
        <span class="hljs-comment">// 子进程执行</span>
        <span class="hljs-keyword">if</span> (!pid) &#123;
            <span class="hljs-comment">// 关闭子进程的 stdin stdout stderr</span>
            close(<span class="hljs-number">0</span>);
            close(<span class="hljs-number">1</span>);
            close(<span class="hljs-number">2</span>);
            <span class="hljs-comment">// 新建会话并设置进程组号</span>
            setsid();
            (<span class="hljs-type">void</span>)open(<span class="hljs-string">&quot;/dev/tty0&quot;</span>, O_RDWR, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 重新打开 tty0 作为 stdin</span>
            (<span class="hljs-type">void</span>)dup(<span class="hljs-number">0</span>);                        <span class="hljs-comment">// 复制得到 stdout stderr</span>
            (<span class="hljs-type">void</span>)dup(<span class="hljs-number">0</span>);
            _exit(execve(<span class="hljs-string">&quot;/bin/sh&quot;</span>, argv,
                         envp));  <span class="hljs-comment">// 再次执行系统解释程序 /bin/sh,</span>
                                  <span class="hljs-comment">// 这里的参数选择了 argv envp</span>
        &#125;
        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)
            <span class="hljs-comment">// 父进程等待子进程结束</span>
            <span class="hljs-keyword">if</span> (pid == wait(&amp;i))
                <span class="hljs-keyword">break</span>;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n\rchild %d died with code %04x\n\r&quot;</span>, pid, i);
        sync();  <span class="hljs-comment">// 同步操作 刷新缓冲区</span>
    &#125;
    _exit(<span class="hljs-number">0</span>); <span class="hljs-comment">/* NOTE! _exit, not exit() */</span>
    <span class="hljs-comment">// _exit 是一个 sys_exit 的系统调用</span>
    <span class="hljs-comment">// exit 是普通函数库中的一个函数</span>
&#125;</code></pre></div>
<p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230322153449.png" srcset="/img/loading.gif" lazyload alt="20230322153449" /></p>
<h3 id="登录"><a class="markdownIt-Anchor" href="#登录"></a> 登录</h3>
<p>在0.11版本的代码中init函数直接开始执行了/bin/sh, 在现代实际可用的系统中还需要处理多人同时使用系统, 区分用户等能力. 通常程序会根据系统 /etc 目录中的配置文件的设置信息, 对系统中支持的每个终端设备创建子进程, 并在子进程中运行终端初始化设置程序 getty 以提示用于输入登录提示信息 login, 当用户键入用户名之后 getty 替换去执行 login 程序, 验证用户输入口令的正确性之后调用 shell 程序并且进入 shell 交互工作界面</p>
<p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230323171144.png" srcset="/img/loading.gif" lazyload alt="20230323171144" /></p>
<h3 id="进程组-会话session"><a class="markdownIt-Anchor" href="#进程组-会话session"></a> 进程组 会话(session)</h3>
<p>当我们使用如下命令的时候, 此命令包含了三个命令行程序 cat grep more, 并使用管道符 <code>|</code> 连接</p>
<div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> init/main.c | grep <span class="hljs-keyword">for</span> | more</code></pre></div>
<div class="code-wrapper"><pre><code class="hljs bash">(base) kamilu@LZX:~/klinux/init$ <span class="hljs-built_in">cat</span> main.c | grep <span class="hljs-keyword">for</span> | more
// 下面这四句用了宏 syscall0 syscall1 去展开, 相当于 int <span class="hljs-function"><span class="hljs-title">fork</span></span>() &#123;...&#125;
static inline _syscall0(int, fork);
    // fork 一个进程并在子进程中执行
    <span class="hljs-keyword">if</span> (!fork()) &#123;
    <span class="hljs-keyword">for</span> (;;) pause();
    // fork 的子进程返回 0
    <span class="hljs-keyword">if</span> (!(pid = fork())) &#123;
        <span class="hljs-keyword">if</span> ((pid = fork()) &lt; 0) &#123;</code></pre></div>
<p>这里的三个进程属于同一个进程组</p>
<p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230323170440.png" srcset="/img/loading.gif" lazyload alt="20230323170440" /></p>
<p>进程组是一个或者多个进程的集合, 每一个进程组都有一个唯一的进程组标识号gid, 每一个进程组有一个称为组长的进程, 组长进程的pid等于进程组的gid</p>
<p>一个进程可以通过setpgid来参加一个现有的进程组或者创建一个新的进程组. 进程组的概念有很多用途, 最常见的是我们在终端上向前台执行程序发出终止信号, 同时终止整个进程组中的所有进程</p>
<p>会话(session) 是一个或多个进程组的集合, 通常情况下用户登录后所执行的所有程序都属于一个会话期, 登陆的shell时会话期的首进程(session header), 当用户退出登录之后 logout, 所有属于我们的会话期的进程都将要被终止, 这是会话期的主要用途之一</p>
<h2 id="todo-登录"><a class="markdownIt-Anchor" href="#todo-登录"></a> TODO 登录</h2>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Linux/">Linux</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/03/21/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%AF%E8%AF%AD/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">操作系统术语</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/03/14/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/gcc%E7%89%88%E6%9C%AC%E5%88%87%E6%8D%A2/">
                        <span class="hidden-mobile">gcc版本切换</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  










  

  
    <!-- KaTeX -->
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css" />
  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>

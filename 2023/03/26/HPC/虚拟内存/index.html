

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
  <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#4a00e0">
  <meta name="author" content="luzhixing12345">
  <meta name="keywords" content="">
  
    <meta name="description" content="简介 一个系统中的进程与其他进程共享CPU和主存资源, 然而共享主存会形成一些特殊的挑战, 例如如果太多的进程需要太多的内存, 那么它们中有一些就根本无法运行; 如果某个进程不小心写入了另一个进程使用的内存, 就可能导致另一个进程以某种完全和程序逻辑无关的方式失败 因此为了更加有效的管理内存并且减少出错情况, 现代操作系统提供了一种对主存的抽象概念: 虚拟内存(Virtual Memory) 虚">
<meta property="og:type" content="article">
<meta property="og:title" content="虚拟内存">
<meta property="og:url" content="https://luzhixing12345.github.io/2023/03/26/HPC/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/index.html">
<meta property="og:site_name" content="kamilu的博客">
<meta property="og:description" content="简介 一个系统中的进程与其他进程共享CPU和主存资源, 然而共享主存会形成一些特殊的挑战, 例如如果太多的进程需要太多的内存, 那么它们中有一些就根本无法运行; 如果某个进程不小心写入了另一个进程使用的内存, 就可能导致另一个进程以某种完全和程序逻辑无关的方式失败 因此为了更加有效的管理内存并且减少出错情况, 现代操作系统提供了一种对主存的抽象概念: 虚拟内存(Virtual Memory) 虚">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/learner-lu/picbed/master/20230326201733.png">
<meta property="og:image" content="https://raw.githubusercontent.com/learner-lu/picbed/master/20230326202802.png">
<meta property="og:image" content="https://raw.githubusercontent.com/learner-lu/picbed/master/20230327101505.png">
<meta property="og:image" content="https://raw.githubusercontent.com/learner-lu/picbed/master/20230327121108.png">
<meta property="og:image" content="https://raw.githubusercontent.com/learner-lu/picbed/master/20230327180631.png">
<meta property="og:image" content="https://raw.githubusercontent.com/learner-lu/picbed/master/20230327101505.png">
<meta property="og:image" content="https://raw.githubusercontent.com/learner-lu/picbed/master/20230327213010.png">
<meta property="og:image" content="https://raw.githubusercontent.com/learner-lu/picbed/master/20230327232815.png">
<meta property="og:image" content="https://raw.githubusercontent.com/learner-lu/picbed/master/20230327234122.png">
<meta property="article:published_time" content="2023-03-26T10:05:47.000Z">
<meta property="article:modified_time" content="2023-03-27T16:21:26.358Z">
<meta property="article:author" content="luzhixing12345">
<meta property="article:tag" content="HPC">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://raw.githubusercontent.com/learner-lu/picbed/master/20230326201733.png">
  
  
  <title>虚拟内存 - kamilu的博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"luzhixing12345.github.io","root":"/","version":"1.8.14","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"fEy8W8VvIoc26nT53dV2157j-gzGzoHsz","app_key":"s9HXuqmvBWrOaAiLA07Jg59A","server_url":"https://fey8w8vv.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":true}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Kamilu-blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://raw.githubusercontent.com/learner-lu/picbed/master/background.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="虚拟内存">
              
                虚拟内存
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2023-03-26 18:05" pubdate>
        2023年3月26日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4.1k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      35 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">虚拟内存</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：1 小时前
                
              </p>
            
            <div class="markdown-body">
              <h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<p>一个系统中的进程与其他进程共享CPU和主存资源, 然而共享主存会形成一些特殊的挑战, 例如如果太多的进程需要太多的内存, 那么它们中有一些就根本无法运行; 如果某个进程不小心写入了另一个进程使用的内存, 就可能导致另一个进程以某种完全和程序逻辑无关的方式失败</p>
<p>因此为了更加有效的管理内存并且减少出错情况, 现代操作系统提供了一种对主存的抽象概念: 虚拟内存(Virtual Memory)</p>
<p>虚拟内存提供了三个重要的能力</p>
<ul>
<li>将主存看作一个高速缓存, 只保存活动区域, 根据需要在磁盘和主存之间来回传输数据</li>
<li>为每个进程提供一致的地址空间, 简化内存管理</li>
<li>保护每个进程的地址空间不被其他进程破坏</li>
</ul>
<p>虚拟内存赋予应用程序强大的能力, 可以创建和销毁内存片(chunk), 将内存片映射到磁盘文件的某个部分, 以及与其他进程共享内存. 比如我们可以通过读写内存位置读或者修改一个磁盘文件的内容, 或者可以加载一个文件的内容到内存中, 而不需要进行显式的复制</p>
<p>同时虚拟内存也是危险的, 当应用程序引用一个变量, 间接引用一个指针, 或者调用一个诸如 malloc 这样的动态分配程序时, 就会与虚拟内存交互, 如果使用不当可能遇到复杂危险的错误, 例如 “段错误” 或者 “保护错误”</p>
<h2 id="物理地址和虚拟地址"><a class="markdownIt-Anchor" href="#物理地址和虚拟地址"></a> 物理地址和虚拟地址</h2>
<p>主存被组织成一个有 M 个连续的字节大小的单元组成的数组, 每一个字节都有唯一的物理地址</p>
<p>CPU访问内存的最自然的方式就是使用物理地址, 这种方式被称为 <strong>物理寻址</strong></p>
<p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230326201733.png" srcset="/img/loading.gif" lazyload alt="20230326201733" /></p>
<p>上图表示 CPU 读取从物理地址 4 开始的连续 4 个字节, 当 CPU 执行这条加载指令的时候会生成一个有效的物理地址, 和取址长度, 通过内存总线传递给主存; 主存根据地址找到物理地址为 4 的单元, 取出连续的 4 个字节, 并将其返回给 CPU, CPU 将其存放在一个寄存器之中</p>
<p>在早期 PC 上使用的是物理地址, 现代 CPU 使用的虚拟地址的寻址方式</p>
<p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230326202802.png" srcset="/img/loading.gif" lazyload alt="20230326202802" /></p>
<p>CPU 通过生成一个虚拟地址(VA)来访问主存, 这个虚拟地址在被送到内存总线之前先传递到 CPU 芯片上的 MMU (Memoryy Management Unit)单元, 将一个虚拟地址转换成物理地址, 在传输给内存. 这一步需要 CPU 硬件和操作系统紧密结合</p>
<p>系统中实际存在的内存空间是物理地址空间, 一共有 M 字节, 其中 M = 2^m, 物理地址空间范围是 {0, 1, …, M - 1}</p>
<p>CPU 从一个 n 位地址空间中构建虚拟地址空间, 一共 N 字节, 其中 N = 2^n, 虚拟地址空间的范围是 {0, 1, …, N-1}</p>
<p>值得注意的是, <strong>虚拟地址空间和物理地址的空间没有什么关系</strong>, 物理内存实际上就是电脑上的内存,一般是 8GB 16GB(2^34)那样; 虚拟地址空间则可以很大, 如果是 64 位的虚拟地址空间, 则可以表示大约 2^64 = 16384P 大小的虚拟地址空间</p>
<blockquote>
<p>另外并不是 64 位机器所用的是 64 位的虚拟地址空间, 这对于虚拟内存来说实在是太大了, linux目前使用的是48位的虚拟地址空间, 即256TB. <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/gettingstarted/virtual-address-spaces">windows 使用的是47位</a>, 即128TB</p>
</blockquote>
<p>虚拟内存可以被看作一个存放在磁盘上的数组, 大小为 N, 每字节都有一个唯一的虚拟地址, 作为到数组的索引. VM 系统通过将虚拟内存分割称为虚拟页(Virtual Page, VP)的大小固定块, 每个虚拟页的大小是 P = 2^p 字节, 类似的物理内存也被分割为物理页(Physical Page, PP), <strong>物理页大小和虚拟页一样都是P字节</strong> , 物理页也可以称为页帧</p>
<blockquote>
<p>Linux 与 Windows 都是采用 4kb作为</p>
</blockquote>
<p>在任意时刻, 虚拟页面的集合都可以分为三个不相交的子集</p>
<ul>
<li>未分配的(unallocated): 没有任何数据和该虚拟页面相关联, 不占用任何磁盘空间</li>
<li>缓存的(cached): 当前虚拟页面已被分配数据, 并且缓存在物理内存中</li>
<li>未缓存的(uncached): 当前虚拟页面已被分配数据, 但未被缓存在物理内存中</li>
</ul>
<p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230327101505.png" srcset="/img/loading.gif" lazyload alt="20230327101505" /></p>
<p>上图中 VP0 VP4 是未分配的页面, VP2 5 7 是已分配并且缓存的, 剩下的是已分配未缓存的</p>
<hr />
<p>这里有几个小问题需要解释一下, 上文说虚拟内存可以被看作一个存放在磁盘上的数组, 大小为 N, 也就是按理来说我们希望 N 刚好为磁盘大小, 但实际上计算机组成的磁盘空间是不确定的, 而操作系统 linux 48位, windows 47位, 也就是说实际上虚拟内存已经在操作系统初始化完成之后确定下来了, 256/128TB, 正常来说这个空间对于我的磁盘是足够大的, 假设我有 1TB 的磁盘, 那么多出来的 255/127TB, 也就是最高位并没有用到, 1TB的磁盘根据虚拟页划分, 映射到虚拟内存, 这没有问题</p>
<p>但是当磁盘空间大于256TB时, 48位的虚拟地址空间就不足了, Linux中如果需要访问大于256TB的磁盘空间，可以使用LVM（逻辑卷管理器）等技术来扩展磁盘空间, 这种特殊情况并不在本文讨论范围之内</p>
<p>也并不是说磁盘空间大于 256TB 就一定要一次性全部映射到虚拟地址空间, 分段映射也是合理的</p>
<p>在早期的系统比如 DEC PDP-11上, 虚拟地址空间甚至比物理地址空间还要小, 但使用虚拟地址空间仍然是一个非常有用的机制, 可以大大简化内存管理, 通常来说在现代操作系统上 物理内存空间 M &lt;&lt; 虚拟内存空间 N</p>
<hr />
<p>下面会涉及到几个概念, SRAM缓存表示 CPU 内部的 L1 L2 L3 高速缓存, 用于缓存主存来的页帧</p>
<p>DRAM缓存是指内存中对于虚拟页的缓存, 也就是上文提到的 “缓存的虚拟页”</p>
<p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230327121108.png" srcset="/img/loading.gif" lazyload alt="20230327121108" /></p>
<p>在存储层级结构中, DRAM 比 SRAM 大约慢 10 倍, 磁盘要比 DRAM 大约慢 100000 倍, 所以 DRAM 缓存不命中带来的惩罚要比 SRAM 缓存不命中多得多, 主要是因为 DRAM 缓存不命中要由磁盘来服务, 而 SRAM 不命中则基于 DRAM 服务, 磁盘扇区的读写速度要比内存慢很多很多</p>
<p>所以我们希望磁盘和 DRAM 之间可以有很好的替换策略, 尽可能地减少 DRAM 缓存不命中的情况</p>
<h2 id="页表"><a class="markdownIt-Anchor" href="#页表"></a> 页表</h2>
<p>与缓存类似, 虚拟内存系统需要有办法可以判断一个虚拟页是否缓存在 DRAM 中, 并且确定存放在哪一个物理页中. 如果缓存不命中, 那么还需要判断虚拟页应该对应磁盘的哪个位置, 并且需要从物理内存中选择一个牺牲页, 将虚拟页从磁盘复制到 DRAM 替换掉牺牲页</p>
<p>虚拟内存系统的功能是由软硬件联合提供的, 包裹操作系统, MMU(内存管理单元) 中的地址翻译硬件和一个存放在物理内存中的<strong>页表</strong>(page table)的数据结构, 页表负责保存虚拟内存到物理内存的映射关系, 操作系统负责维护页表的内容, 当地址翻译硬件试图将一个虚拟地址转换到物理地址的时候会读取页表, 然后根据页表中的信息找到对应的物理地址</p>
<p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230327180631.png" srcset="/img/loading.gif" lazyload alt="20230327180631" /></p>
<p>上图是一个页表的基本结构, 页表是常驻内存的, 它是一个页表条目(PTE, Page Table Entry)的数组, 每一个页表条目有一个有效位(valid bit)和 m 位的磁盘地址组成</p>
<blockquote>
<p>这里的 m 是上文提到过的物理地址空间的大小, M = 2^m</p>
</blockquote>
<p>上图中左侧是页表, 我们可以根据其中的索引找到对应的 PTE.</p>
<ul>
<li>
<p>如果有效位为1则说明该 PTE 构建了一个从 VP 到 PP 的映射, PTE 中的 n 位地址是主存中的物理页号</p>
</li>
<li>
<p>如果有效位为0</p>
<ul>
<li>如果 n 位地址不空, 则该 PTE 没有使用, 但已经与一个 VP 绑定了, 即未缓存虚拟页</li>
<li>如果 n 位地址为空, 则该 PTE 还没有被分配</li>
</ul>
</li>
</ul>
<p>这里注意要与之前的虚拟页和物理页区分开, 虚拟页是在磁盘中的, 物理页是在 DRAM 中, 页表也是在 DRAM 中, 下图中的映射关系没有改变, 只是借助页表这一数据结构实现了一种映射关系</p>
<p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230327101505.png" srcset="/img/loading.gif" lazyload alt="20230327101505" /></p>
<h3 id="页命中与缺页"><a class="markdownIt-Anchor" href="#页命中与缺页"></a> 页命中与缺页</h3>
<p>当 CPU 想要读 VP2 虚拟内存中的一个字的时候, CPU 将虚拟地址发送给 MMU, MMU 查找页表进行地址转换, 通过某种技术通过虚拟地址定位到索引, 找到页表中的 PTE2, 发现其有效位为 1, 说明该 PTE 有效, 则取出其中保存的物理内存地址, 找到物理内存中的数据, 如下图所示</p>
<p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230327213010.png" srcset="/img/loading.gif" lazyload alt="20230327213010" /></p>
<p>但如果 CPU 发出一条指令希望读取 VP3, 此时发现有效位为0, 说明 VP3 并未被缓存, 操作系统触发一个缺页异常, 调用内核的缺页异常处理程序, 选择 DRAM 中的一个物理页作为牺牲页, 假设选中的是位于 PP3 的 VP4, 则内核从磁盘复制 VP3 到内存 PP3, 更新 PTE3, 如下图所示</p>
<p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230327232815.png" srcset="/img/loading.gif" lazyload alt="20230327232815" /></p>
<p>当异常处理程序返回的时候, CPU会重新启动导致缺页的指令, 把之前导致缺页的虚拟地址重新发送到 MMU, 此时VP3 已经缓存在 DRAM 中了, 所以正常处理执行</p>
<p>关于虚拟内存有如下的一些相关名词, 磁盘和内存之间传送页被叫做 <strong>交换</strong> 或者 <strong>页面调度</strong>, 当有不命中发生的时候才换入页面的调度策略叫做 <strong>按需页面调度</strong>, 这也是现代所有系统都使用的页面调度策略</p>
<p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230327234122.png" srcset="/img/loading.gif" lazyload alt="20230327234122" /></p>
<p>实际上操作系统为每一个进程都提供了独立的页表, 也就是每一个进程都会对应以一个独立的地址空间, 上图中只展示了 VP 和 PP的部分, 地址翻译的过程对应页表, 我们注意到进程i的 VP2 和进程j的 VP1对应的都是 PP7 的物理页面, 说明多个虚拟页面可以映射到同一个物理页面当中</p>
<ul>
<li>
<p>简化链接</p>
<p>独立的虚拟地址空间允许每个进程的内存映像使用相同的基本格式, 比如 64 位地址空间中所有代码拗断都是 0x400000 开始的, 数据段在代码短之后, 栈段从用户进程的最高地址空间向下生长</p>
<p>这样的一致性的地址空间大大简化了链接器的设计和实现, 不再需要去关系实际物理内存中的地址映射关系, 而是在一个统一的地址视图中执行程序</p>
</li>
<li>
<p>简化加载</p>
<p>当我们运行一个可执行文件的时候, 我们希望将其加载到内存中, Linux 加载器只需要简单的为代码段和数据段分配虚拟页, 然后将其标志位置 0, 加载器实际上并不从磁盘复制任何数据到内存, 只是创建一个未缓存的虚拟页, 该进程分配到时间片开始执行之后再通过缺页中断完成加载</p>
<p>将一组连续的虚拟页映射到任意一个文件的任意位置称为 <strong>内存映射</strong>, Linux 提供了一个 mmap 的系统调用, 允许应用程序自己做内存映射</p>
</li>
<li>
<p>简化共享</p>
<p>每个进程有自己的代码, 数据, 堆, 栈, 不与其他进程共享. 但通常来说我们会需要进程共享代码和数据, 比如每个进程都可能需要调用系统调用以及一些 C 标准库的程序, 比如 printf; 操作系统只需要将这部分经常使用的程序加载到内存一次, 让其他所有进程在使用的时候映射到相同的物理页面即可, 而不是为每个进程都创建一份副本</p>
</li>
<li>
<p>简化内存分配</p>
<p>当程序调用 malloc 希望分配在堆空间分配一块内存的时候, 操作系统只需要分配 k 个连续的虚拟内存页面, 然后将其映射到物理内存中的任意k 个物理页面即可, 虚拟内存页面需要连续, 但是物理内存的页面没有必要连续, 可以由操作系统的内存分配器寻找最合适的位置</p>
</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/HPC/">HPC</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/03/23/Linux/Linux011-kernel/">
                        <span class="hidden-mobile">Linux0.11-kernel</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  










  

  
    <!-- KaTeX -->
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css" />
  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
